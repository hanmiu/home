<!doctype html>
<meta charset="utf-8">
<title>몸문자</title>
<style title="main">
  @import url('https://fonts.googleapis.com/css?family=Black+Han+Sans');
  @import url('https://fonts.googleapis.com/css?family=Do+Hyeon');
  
  html {
    overflow: hidden; 
  }
  
  body {
    margin: 0;
    user-select: none;
    overflow: hidden;
  }
  
  .glyph {
  }
  
  .gpath {
    transform: scale(0, 0);
    transition: transform 0.2s;
  }
  
  .desc {
    font-family: 'Black Han Sans', sans-serif;
    font-size: 30px;
    opacity: 0;
    transition: opacity 0.2s;
    transform: translate(0px, 100px);
  }
  
  .gpath {
    fill: blue;
    cursor: pointer;
  }
  
  #ui {
    position: fixed;
    left: 0px;
    top: 0px;
    width: 100vw;
    height: 10vh;
    /* background-color: #30f09f; */
  }
  
  #ui .button {
    margin-top: 5vh;
    margin-left: 3vw;
    margin-right: 1vw;
    display: inline-block;
    font-size: 4vw;
    font-family: 'Black Han Sans', sans-serif;
    padding: 1vh 2vw 1vh 2vw;
    border-radius: 2vw;
    background-color: antiquewhite; 
  }
  
  #ui .button:active {
    background-color: #eabf85; 
  }
  
  #svg {
    position: fixed;
  }
  
  #info {
    position: fixed;
    right: 0px;
    bottom: 0px;
    font-size: 2em;
  }
  
  #pane {
    position: fixed;
    left: 0px;
    top: 0px;
    width: 100px;
    height: 100vh;
    background-color: aquamarine;
    overflow-x: hidden;
    overflow-y: scroll;
    display: none;
  }
  
  .item {
    width: 80px;
    height: 80px;
    border-radius: 40px;
    background-color: blueviolet;
  }
  
  input {
    transform-origin: left top;
    transform: scale(2, 2);
  }
  
  #drawer {
    position: fixed;
    width: 100vw;
    height: 33vh;
    left: 0px;
    bottom: 0px;
    background-color: beige;
    overflow: hidden;
  }
  
  #dictionary {
    margin-left: 5vw;
    margin-right: 5vw;
    margin-top: 5vh;
  }
  
  .bt-glyph {
    display: inline-block;
    width: 10vh;
    height: 10vh;
    margin: 3px;
    background-repeat: no-repeat;
  }
  
  #message {
    position: fixed;
    width: 100vw;
    height: 100vh;
    left: 0px;
    top: 0px;
    font-size: 5vw;
    text-align: center;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    line-height: 33vh;
  }
</style>
<body>
  <svg id="svg"></svg>
  <div id="ui">
    <div id="show" class="button">보이기</div>
    <div id="hide" class="button">숨기기</div>
  </div>
  
  <div id="pane"></div>
  <div id="drawer">
    <div id="dictionary"></div>
  </div>
  
  <!--<div id="message">
    <div id="inner">아직 만드는 중,<br>늦어져서 미안해요!<br>12월 25일 아침까지 기다려 주세요.</div>
  </div>
  -->
  <div id="info">0</div>
</body>
<script>
  let svg_ns = 'http://www.w3.org/2000/svg';
  let el_svg = document.querySelector('#svg');
  let el_ui = document.querySelector('#ui');
  let el_pane = document.querySelector('#pane');
  let rect_svg = el_svg.getBoundingClientRect();
  let rect_ui = el_ui.getBoundingClientRect();
  let base_scale = 0.0;
  
  let checkbox_show_desc = document.querySelector('#show-desc');
  
  let main_stylesheet = [].slice.call(document.styleSheets).filter(x => x.title == 'main')[0];
  
  function get_style_rule(selectorText) {
    return [].slice.call(main_stylesheet.cssRules).filter(x => x.selectorText == selectorText)[0];
  }
  
  let style_desc = get_style_rule('.desc').style;
  
  let files = [
    '새.svg',
    '모른다.svg',
    '풀 위에 토끼.svg',
  ];
  
  let dom_parser = new DOMParser();
  let dic_glyph_data = {};
  let ptcls = [];
  
  function add_glyph(name, x, y) {
    let d = dic_glyph_data[name];
    if(d) {
      let group = document.createElementNS(svg_ns, 'g');
      group.setAttribute('class', 'glyph');

      let gpath = document.createElementNS(svg_ns, 'path');
      gpath.setAttribute('class', 'gpath');
      gpath.setAttribute('d', d);

      let desc = document.createElementNS(svg_ns, 'text');
      desc.setAttribute('class', 'desc');
      desc.setAttribute('text-anchor', 'middle');
      desc.setAttribute('alignment-baseline', 'middle');
      desc.textContent = name;
      desc.setAttribute('x', 0);
      desc.setAttribute('y', 0);

      group.style.transform = `translate(${x}px, ${y}px)`;

      group.appendChild(desc);
      group.appendChild(gpath);
      el_svg.appendChild(group);

      group.info = {
        x: x,
        y: y,
        radius: 1.0,
        name: name,
      };
      ptcls.push(group);

      let bbox = gpath.getBBox();
      gpath.style.transform = `scale(${base_scale}, ${base_scale}) translate(${-bbox.width*0.5}px, ${-bbox.height*0.5}px)`;  
    }
  }
  
  function add_bt_glyph(name) {
    let d = dic_glyph_data[name];
    if(d) {
      let path = document.createElementNS(svg_ns, 'path');
      path.setAttribute('d', d);
      el_svg.appendChild(path);
      let bbox = path.getBBox();
      let cx = (bbox.x + bbox.width) * 0.5;
      let cy = (bbox.y + bbox.height) * 0.5;
      path.remove();
      
      let svg_xml = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><path fill="brown" transform="translate(20, 20) scale(0.09, 0.09) translate(${-cx}, ${-cy})" d="${d}"/></svg>`;
      let url = `data:image/svg+xml;utf8,${svg_xml}`;
      let el = document.createElement('div');
      el.className = 'bt-glyph';
      el.style['background-image'] = `url('${url}')`;
      document.querySelector('#dictionary').appendChild(el);
      
      el.onclick = function(e) {
        console.log(name);
        add_glyph(name, innerWidth * 0.5 + (Math.random()*2-1)*10, 100);
        layout();
      };
    }
  }
  
  function load_glyph_data() {
    for(let file of files) {
      fetch('./data/mmj/' + file)
      .then(response => response.text())
      .then(text => {
        let xml = dom_parser.parseFromString(text, 'text/xml');
        let paths = xml.querySelectorAll('path');

        for(let i = 0; i < paths.length; i++) {
          let d = paths[i].getAttribute('d').trim();
          if(d.length > 0) {
            let name = file.split('.')[0];
            dic_glyph_data[name] = d;
            add_bt_glyph(name);
          }
        }
      });  
    }
  }
  
  /*
  for(let file of files) {
    fetch('./data/mmj/' + file)
    .then(response => response.text())
    .then(text => {
      let xml = dom_parser.parseFromString(text, 'text/xml');
      let paths = xml.querySelectorAll('path');

      for(let i = 0; i < paths.length; i++) {
        let d = paths[i].getAttribute('d');
        if(d.trim().length > 0) {
          let name = file.split('.')[0];
          let group = document.createElementNS(svg_ns, 'g');
          group.setAttribute('class', 'glyph');
          
          let gpath = document.createElementNS(svg_ns, 'path');
          gpath.setAttribute('class', 'gpath');
          gpath.setAttribute('d', d);
          
          let desc = document.createElementNS(svg_ns, 'text');
          desc.setAttribute('class', 'desc');
          desc.setAttribute('text-anchor', 'middle');
          desc.setAttribute('alignment-baseline', 'middle');
          desc.textContent = name;
          desc.setAttribute('x', 0);
          desc.setAttribute('y', 0);
          
          let x = Math.random() * innerWidth;
          let y = Math.random() * innerHeight;
          group.style.transform = `translate(${x}px, ${y}px)`;
          
          group.appendChild(desc);
          group.appendChild(gpath);
          el_svg.appendChild(group);
          
          group.info = {
            x: x,
            y: y,
            radius: 1.0,
            name: name,
          };
          ptcls.push(group);
          
          let bbox = gpath.getBBox();
          gpath.style.transform = `scale(${base_scale}, ${base_scale}) translate(${-bbox.width*0.5}px, ${-bbox.height*0.5}px)`;
        }
      }
    });  
  }
  */
  
  let touch = {
    down: false,
    px: 0,
    py: 0,
    dx: 0,
    dy: 0,
    x: 0,
    y: 0,
    glyph: null,
  };
  
  function touchstart(target, x, y) {
    touch.glyph = target;
    let rect = target.getBoundingClientRect();
    
    touch.dx = x - touch.glyph.info.x;
    touch.dy = y - touch.glyph.info.y;
    
    touch.down = true;
    touch.px = touch.x;
    touch.py = touch.y;
    touch.x = x;
    touch.y = y;
  }
  
  function touchend() {
    touch.down = false;
    touch.px = touch.x;
    touch.py = touch.y;
    touch.glyph = null;
  }
  
  function touchmove(x, y) {
    touch.px = touch.x;
    touch.py = touch.y;
    touch.x = x;
    touch.y = y;
    
    if(touch.down) {
      let x = touch.x - touch.dx;
      let y = touch.y - touch.dy;
      touch.glyph.style.transform = `translate(${x}px, ${y}px)`;
      touch.glyph.info.x = x;
      touch.glyph.info.y = y;
      document.querySelector('#info').textContent = `${x|0}, ${y|0}`;
    }
  }
  
  function find_nearest_touchable(x, y) {
    let min_d = Number.MAX_VALUE;
    let gp = null;
    for(let glyph of ptcls) {
      let dx = x - glyph.info.x;
      let dy = y - glyph.info.y - rect_svg.top;
      let d = Math.sqrt(dx*dx + dy*dy);
      if(d < min_d) {
        min_d = d;
        gp = glyph;
      }
    }

    if(gp) {
      let rect = gp.querySelector('.gpath').getBoundingClientRect();
      if((x > rect.left && x < rect.right) && (y > rect.top && y < rect.bottom)) {
        touchstart(gp, x, y);   
      }
      else {
        console.log('add here');
      }
    }
  }
  
  el_svg.onmousedown = function(e) {
    if(e.target.getAttribute('class') == 'gpath' && touch.glyph == null) {
      touchstart(e.target.parentElement, e.pageX, e.pageY);
    }
  };
  
  el_svg.onmouseup = function(e) {
    touchend();
  };
  
  el_svg.onmousemove = function(e) {
    touchmove(e.pageX, e.pageY);
  };
  
  el_svg.ontouchstart = function(e) {
    if(e.target.getAttribute('class') == 'gpath' && touch.glyph == null) {
      if(e.touches.length > 0) {
        touchstart(e.target.parentElement, e.touches[0].pageX, e.touches[0].pageY);
      }
      e.preventDefault();
    }
    else {
      find_nearest_touchable(e.touches[0].pageX, e.touches[0].pageY);
    }
  };
  
  el_svg.ontouchend = function(e) {
    touchend();
    e.preventDefault();
  };
  
  el_svg.ontouchmove = function(e) {
    if(e.touches.length > 0) {
      touchmove(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  };
  
  document.querySelector('#show').onclick = function() {
    style_desc['opacity'] = 1;
  };
  
  document.querySelector('#hide').onclick = function() {
    style_desc['opacity'] = 0;
  };
  
  /*
  checkbox_show_desc.oninput = function() {
    if(checkbox_show_desc.checked) {
      //style_desc['transform'] = 'translate(0px, 100px) scale(1, 1)';
      let descs = document.querySelectorAll('.desc');
      for(let desc of descs) {
        desc.setAttribute('opacity', 1);
      }
      document.querySelector('#ui').style.backgroundColor = 'yellow';
    }
    else {
      //style_desc['transform'] = 'translate(0px, 100px) scale(0, 0)';
      let descs = document.querySelectorAll('.desc');
      for(let desc of descs) {
        desc.setAttribute('opacity', 0);
      }
      document.querySelector('#ui').style.backgroundColor = 'cyan';
    } 
  };
  */
  
  function layout () {
    document.querySelector('#info').textContent = window.scrollY;
    rect_ui = el_ui.getBoundingClientRect();
    el_svg.setAttribute('width', innerWidth);
    el_svg.setAttribute('height', innerHeight - rect_ui.bottom + window.scrollY);
    el_svg.style.left = '0px';
    el_svg.style.top = rect_ui.height + 'px';
    rect_svg = el_svg.getBoundingClientRect();
    
    let aspect_ratio = innerWidth / innerHeight;
    let nw = aspect_ratio > 1.0 ? 10 : 7;
    let size = innerWidth / nw;
    base_scale = size / 300;
    let r_scale = aspect_ratio > 1.0 ? 1.0 : 10.0 / 7.0;
    
    let glyphs = document.querySelectorAll('.glyph');
    
    for(let glyph of glyphs) {
      let gpath = glyph.querySelector('.gpath');
      let bbox = gpath.getBBox();
      gpath.style.transform = `scale(${base_scale}, ${base_scale}) translate(${-bbox.width*0.5}px, ${-bbox.height*0.5}px)`;
      let rect = gpath.getBoundingClientRect();
      glyph.info.radius = Math.min(bbox.width, bbox.height) * 0.25 * r_scale;
      
      if(rect.right > rect_svg.right) {
        glyph.info.x = rect_svg.right - rect.width;
      }
      if(rect.left < rect_svg.left) {
        glyph.info.x = rect_svg.left + rect.width;
      }
      if(rect.bottom > rect_svg.bottom) {
        glyph.info.y = rect_svg.bottom - rect.height;
      }
      if(rect.top < rect_svg.top) {
        glyph.info.y = rect.height;
      }
      glyph.style.transform = `translate(${glyph.info.x}px, ${glyph.info.y}px)`;
    }
  }
  
  window.onresize = function() {
    setTimeout(layout, 500);
  };
  
  window.onload = function() {
    load_glyph_data();
    
    setTimeout(layout, 500);
    
    for(let i = 0; i < 100; i++) {
      let el = document.createElement('div');
      el.className = 'item';
      el.textContent = i;
      el_pane.appendChild(el);
    }
    
    loop();
  };
  
  function scene_update() {
    for(let j = 0; j < ptcls.length; j++) {
      let ptcl = ptcls[j];
      for(let i = 0; i < ptcls.length; i++) {
        let other = ptcls[i];
        if(ptcl != other) {
          let dx = ptcl.info.x - other.info.x;
          let dy = ptcl.info.y - other.info.y;
          let d = Math.sqrt(dx*dx + dy*dy);
          let r = ptcl.info.radius + other.info.radius;
          if(d < r && d > 0) {
            let dr = r - d;
            let ux = dx / d;
            let uy = dy / d;
            ptcl.info.x += dr * 0.5 * ux;
            ptcl.info.y += dr * 0.5 * uy;
            ptcl.style.transform = `translate(${ptcl.info.x}px, ${ptcl.info.y}px)`;
          }
        }
      }
    }
  }
  
  function loop() {
    scene_update();
    requestAnimationFrame(loop);
  }
</script>