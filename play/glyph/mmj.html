<!doctype html>
<meta charset="utf-8">
<title>몸문자</title>
<style title="main">
  @import url('https://fonts.googleapis.com/css?family=Black+Han+Sans');
  @import url('https://fonts.googleapis.com/css?family=Do+Hyeon');
  
  html {
    overflow: hidden; 
  }
  
  body {
    margin: 0;
    user-select: none;
    overflow: hidden;
  }
  
  .gpath {
    transform: scale(0, 0);
    transition: transform 0.2s;
  }
  
  .desc {
    font-family: 'Black Han Sans', sans-serif;
    font-size: 30px;
    opacity: 0;
    transition: opacity 0.2s;
    /* transform: translate(0px, 100px); */
  }
  
  .gpath {
    fill: black;
    cursor: pointer;
  }
  
  #ui {
    position: fixed;
    left: 0px;
    top: 0px;
    width: 100vw;
    text-align: center;
    background-color: rgba(255, 255, 255, 0.9);
    transition: top 0.25s;
  }
  
  #ui .button {
    margin-top: 5vh;
    margin-left: 3vw;
    margin-right: 1vw;
    margin-bottom: 1vh;
    display: inline-block;
    font-size: 4vw;
    font-family: 'Black Han Sans', sans-serif;
    padding: 1vh 2vw 1vh 2vw;
    border-radius: 2vw;
    background-color: antiquewhite; 
  }
  
  #ui .button:active {
    background-color: #eabf85; 
  }
  
  #svg {
    position: fixed;
  }
  
  #info {
    display: none;
    position: fixed;
    right: 0px;
    bottom: 0px;
    font-size: 2em;
  }
  
  .item {
    width: 80px;
    height: 80px;
    border-radius: 40px;
    background-color: blueviolet;
  }
  
  #drawer {
    position: fixed;
    width: 100vw;
    height: 33vh;
    left: 0px;
    bottom: 0px;
    background-color: beige;
    overflow: hidden;
    transition: bottom 0.5s;
  }
  
  #dictionary {
    margin-left: 5vw;
    margin-right: 5vw;
    margin-top: 5vh;
    margin-bottom: 5vh;
    height: 23vh;
    overflow-y: scroll;
  }
  
  .bt-glyph {
    display: inline-block;
    width: 10vh;
    height: 10vh;
    margin: 3px;
    background-repeat: no-repeat;
    border-radius: 2vh;
  }
  
  .bt-glyph:active {
    background-color: burlywood;
  }
  
  #message {
    display: none;
    position: fixed;
    /* width: 100vw;
    height: 100vh; */
    left: 2vh;
    bottom: 2vh;
    font-size: 3vh;
    /* text-align: center;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    line-height: 33vh;
    */
    color: rgb(0, 0, 0, 0.25);
  }
  
  #logo {
    position: fixed;
    right: 1vw;
    bottom: 1vh;
  }
  
  #logotype {
    stroke-linecap: round;
    stroke-linejoin: round;
    stroke-miterlimit: 1.5;
  }
  
  #logotype path {
    stroke-width: 4.5px;
    stroke: rgb(211, 211, 211);
    fill: none;
  }
  
  #trashcan {
    display: flex;
    align-items: center;
    justify-content: center;
    position: fixed;
    right: -10vw;
    top: 0vh;
    width: 10vw;
    height: 100vh;
    background-color: #d8d8d8;
    transition: right 0.5s;
    font-family: 'Black Han Sans', sans-serif;
    font-size: 3vw;
    line-height: 5vw;
    color: #6d6d6d;
  }
  
  @media print {
    /*
    html, body {
      width: 210mm;
      height: 297mm;
    }
    */
    #ui {
      display: none;  
    }
  }
</style>
<body>
  <div id="trashcan">버<br>리<br>기</div>
  <svg id="svg"></svg>
  <div id="ui">
    <div id="pick" class="button">고르기</div>
    <div id="show" class="button">보이기</div>
    <div id="hide" class="button">감추기</div>
    <div id="print" class="button">프린트</div>
  </div>
  
  <div id="logo">
    <svg id="logotype" height="50" viewBox="0 0 305 100">
      <path d="M26.405 23.245 C26.405 23.245 26.881 26.114 27.220 29.950"></path>
      <path d="M11.354 29.950 L41.454 29.950"></path>
      <path d="M37.190 48.339 C37.190 43.725 33.062 39.980 27.979 39.980 L24.830 39.980 C19.746 39.980 15.620 43.725 15.620 48.339 C15.620 52.953 19.746 56.697 24.830 56.697 L27.979 56.697 C33.062 56.697 37.190 52.953 37.190 48.339 Z"></path>
      <path d="M54.946 23.241 L54.946 60.041"></path>
      <path d="M54.945 43.324 L64.902 43.324"></path>
      <path d="M18.038 66.730 C18.038 71.342 16.822 76.787 25.891 76.760 L58.121 76.760"></path>
      <path d="M77.431 29.950 L100.399 29.950 L100.399 63.385 L77.431 63.385 Z"></path>
      <path d="M117.555 23.263 L117.555 73.417"></path>
      <path d="M171.459 34.571 C171.459 28.397 166.278 23.386 159.897 23.386 L155.944 23.386 C149.561 23.386 144.382 28.397 144.382 34.571 C144.382 40.744 149.561 45.755 155.944 45.755 L159.897 45.755 C166.278 45.755 171.459 40.744 171.459 34.571 Z"></path>
      <path d="M151.173 76.708 C151.173 62.099 152.196 54.288 142.887 53.984 C135.824 53.754 132.047 49.789 131.672 45.756"></path>
      <path d="M164.606 76.760 C164.606 62.151 163.644 54.340 172.954 54.036 C180.017 53.806 183.794 50.522 184.168 46.489"></path>
      <path d="M193.295 33.337 L220.044 33.337"></path>
      <path d="M206.677 26.649 C206.677 26.649 208.893 40.002 206.677 46.092 C204.447 52.221 193.314 63.261 193.296 63.429"></path>
      <path d="M206.675 46.092 L220.043 63.429"></path>
      <path d="M233.419 23.263 L233.419 73.417"></path>
      <path d="M273.707 31.600 C273.707 26.986 269.579 23.241 264.497 23.241 L261.348 23.241 C256.264 23.241 252.137 26.986 252.137 31.600 C252.137 36.214 256.264 39.958 261.348 39.958 L264.497 39.958 C269.579 39.958 273.707 36.214 273.707 31.600 Z"></path>
      <path d="M246.856 50.012 C263.000 50.801 272.258 51.404 280.395 46.668"></path>
      <path d="M262.923 59.077 C262.923 59.077 263.527 55.428 263.959 50.550"></path>
      <path d="M282.312 57.379 L292.270 57.379"></path>
      <path d="M292.293 23.241 L292.293 63.407"></path>
      <path d="M253.685 66.730 C253.685 71.342 252.468 76.787 261.537 76.760 L293.767 76.760"></path>
    </svg>
  </div>
  <div id="drawer">
    <div id="dictionary"></div>
  </div>
  
  <div id="message">
    <div id="inner">계속 만드는 중, 문자를 클릭하고 움직이며 실험해 보세요!</div>
  </div>
  <div id="info">0</div>
</body>
<script>
  let svg_ns = 'http://www.w3.org/2000/svg';
  let el_svg = document.querySelector('#svg');
  let el_ui = document.querySelector('#ui');
  
  let el_trashcan = document.querySelector('#trashcan');
  let el_drawer = document.querySelector('#drawer');
  let el_dictionary = document.querySelector('#dictionary');
  let el_pick = document.querySelector('#pick');
  let el_show = document.querySelector('#show');
  let el_hide = document.querySelector('#hide');
  let el_print = document.querySelector('#print');
  
  let el_logo = document.querySelector('#logo');
  let rect_svg = el_svg.getBoundingClientRect();
  let rect_ui = el_ui.getBoundingClientRect();
  let base_scale = 0.0;
  
  let checkbox_show_desc = document.querySelector('#show-desc');
  
  let main_stylesheet = [].slice.call(document.styleSheets).filter(x => x.title == 'main')[0];
  
  function get_style_rule(selectorText) {
    return [].slice.call(main_stylesheet.cssRules).filter(x => x.selectorText == selectorText)[0];
  }
  
  let style_desc = get_style_rule('.desc').style;
  let style_bt_glyph = get_style_rule('.bt-glyph').style;
  
  let files = [
    '새.svg',
    '모른다.svg',
    '나무.svg',
    '있다.svg',
    '즐겁다.svg',
    '논다.svg',
    '다시.svg',
    '지치다.svg',
    '유치원.svg',
    '집.svg',
    '화장실.svg',
    '풀 위에 토끼.svg',
    '토끼를 잡은 사냥꾼.svg',
    '없다.svg',
    '사람.svg',
    '가다.svg',
    '나.svg',
    '너.svg',
    '우리.svg',
    '만들다.svg',
    '또.svg',
    '그리고.svg',
    '사랑.svg',
    '먹다.svg',
    '최고.svg',
    '그런데.svg',
    '골프.svg',
    '계속.svg',
    '들다.svg',
    '공.svg',
    '싸우다.svg',
    '밥.svg',
    '축구.svg',
    '야구.svg',
    '표창.svg',
    '수영.svg',
    '하다.svg',
    '치킨.svg',
    '총을 쏘다.svg',
    '안경.svg',
    '마트.svg',
    '초코우유.svg',
    '사다.svg',
    '돈.svg',
    '은행.svg',
    '빌리다.svg',
    '딸기우유.svg',
    '달라고.svg',
    '편의점.svg',
    '아저씨.svg',
    '잡다.svg',
    '유령.svg',
    '가리다.svg',
    '풀다.svg',
    '술래잡기.svg',
    '손수건.svg',
    '무엇.svg',
    '많이.svg',
    '눈.svg',
    '놀라다.svg',
    '이야기.svg',
    '그래서.svg',
    '갑자기.svg',
  ];
  
  let dom_parser = new DOMParser();
  let dic_glyph_data = {};
  let ptcls = [];
  let dragging = 0;
  let wait = 0;
  
  function add_glyph(name, x, y) {
    let d = dic_glyph_data[name];
    if(d) {
      let group = document.createElementNS(svg_ns, 'g');
      group.setAttribute('class', 'glyph');

      let gpath = document.createElementNS(svg_ns, 'path');
      gpath.setAttribute('class', 'gpath');
      gpath.setAttribute('d', d);

      let desc = document.createElementNS(svg_ns, 'text');
      desc.setAttribute('class', 'desc');
      desc.setAttribute('text-anchor', 'middle');
      desc.setAttribute('alignment-baseline', 'middle');
      desc.textContent = name;
      desc.setAttribute('x', 0);
      desc.setAttribute('y', 0);

      group.style.transform = `translate(${x}px, ${y}px)`;

      group.appendChild(desc);
      group.appendChild(gpath);
      el_svg.appendChild(group);

      group.info = {
        x: x,
        y: y,
        fx: 0.5,
        fy: 0.5,
        radius: 1.0,
        name: name,
      };
      ptcls.push(group);
      
      let aspect_ratio = innerWidth / innerHeight;
      let nw = aspect_ratio > 1.0 ? 10 : 7;
      let size = innerWidth / nw;
      base_scale = size / 300;
      let r_scale = aspect_ratio > 1.0 ? 1.0 : 10.0 / 7.0;
      
      desc.setAttribute('transform', `translate(0, ${260 * base_scale})`);

      let bbox = gpath.getBBox();
      gpath.style.transform = `scale(${base_scale}, ${base_scale}) translate(${-bbox.width*0.5}px, ${-bbox.height*0.5}px)`;
      group.info.radius = Math.min(bbox.width, bbox.height) * 0.25 * r_scale;
      group.info.fx = x / innerWidth;
      group.info.fy = y / innerHeight;
    }
  }
  
  function add_bt_glyph(name) {
    let d = dic_glyph_data[name];
    if(d) {
      let path = document.createElementNS(svg_ns, 'path');
      path.setAttribute('d', d);
      el_svg.appendChild(path);
      let bbox = path.getBBox();
      let cx = (bbox.x + bbox.width) * 0.5;
      let cy = (bbox.y + bbox.height) * 0.5;
      path.remove();
      
      let svg_xml = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><path fill="black" transform="translate(20, 20) scale(0.09, 0.09) translate(${-cx}, ${-cy})" d="${d}"/></svg>`;
      let url = `data:image/svg+xml;utf8,${svg_xml}`;
      let el = document.createElement('div');
      el.className = 'bt-glyph';
      el.style['background-image'] = `url('${url}')`;
      document.querySelector('#dictionary').appendChild(el);
      
      el.onclick = function(e) {
        add_glyph(name, innerWidth * 0.5 + (Math.random()*2-1)*10, innerHeight * 0.5);
        wait = 60 * 8;
      };
    }
  }
  
  async function load_glyph_data() {
    for(let file of files) {
      await fetch('./data/mmj/' + file)
      .then(response => response.text())
      .then(text => {
        let xml = dom_parser.parseFromString(text, 'text/xml');
        let paths = xml.querySelectorAll('path');

        for(let i = 0; i < paths.length; i++) {
          let d = paths[i].getAttribute('d').trim();
          if(d.length > 0) {
            let name = file.split('.')[0];
            dic_glyph_data[name] = d;
            add_bt_glyph(name);
          }
        }
      });  
    }
  }
  
  let touch = {
    down: false,
    px: 0,
    py: 0,
    dx: 0,
    dy: 0,
    x: 0,
    y: 0,
    glyph: null,
  };
  
  function touchstart(target, x, y) {
    touch.glyph = target;
    let rect = target.getBoundingClientRect();
    
    touch.dx = x - touch.glyph.info.x;
    touch.dy = y - touch.glyph.info.y;
    
    touch.down = true;
    touch.px = touch.x;
    touch.py = touch.y;
    touch.x = x;
    touch.y = y;
    
    dragging = 20;
  }
  
  function touchend() {
    touch.down = false;
    touch.px = touch.x;
    touch.py = touch.y;
    if(touch.glyph) {
      let rect = el_trashcan.getBoundingClientRect();
      if(touch.x > rect.left) {
        let idx = ptcls.indexOf(touch.glyph);
        ptcls.splice(idx, 1);
        touch.glyph.remove();
      }
    }
    touch.glyph = null;
    el_trashcan.style['right'] = '-10vw';
  }
  
  function touchmove(x, y) {
    touch.px = touch.x;
    touch.py = touch.y;
    touch.x = x;
    touch.y = y;
    
    if(touch.down) {
      let x = touch.x - touch.dx;
      let y = touch.y - touch.dy;
      touch.glyph.style.transform = `translate(${x}px, ${y}px)`;
      touch.glyph.info.x = x;
      touch.glyph.info.y = y;
      touch.glyph.info.fx = x / innerWidth;
      touch.glyph.info.fy = y / innerHeight;
      //document.querySelector('#info').textContent = `${x|0}, ${y|0}`;
      //document.querySelector('#info').textContent = `${window.scrollY}`;
      //let rect = el_svg.getBoundingClientRect();
      //document.querySelector('#info').textContent = `${rect.left},${rect.top},${rect.width},${rect.height}`;
      if(dragging > 0) {
        dragging--;
        if(dragging == 0) {
          el_trashcan.style['right'] = '0vw';  
        }
      }
    }
  }
  
  function find_nearest_touchable(x, y) {
    y -= window.scrollY;
    let min_d = Number.MAX_VALUE;
    let gp = null;
    for(let glyph of ptcls) {
      let dx = x - glyph.info.x;
      let dy = y - glyph.info.y;
      let d = Math.sqrt(dx*dx + dy*dy);
      if(d < min_d) {
        min_d = d;
        gp = glyph;
      }
    }

    if(gp) {
      let rect = gp.querySelector('.gpath').getBoundingClientRect();
      if((x > rect.left && x < rect.right) && (y > rect.top && y < rect.bottom)) {
        touchstart(gp, x, y + window.scrollY);   
      }
    }
  }
  
  el_svg.onmousedown = function(e) {
    if(e.target.getAttribute('class') == 'gpath' && touch.glyph == null) {
      touchstart(e.target.parentElement, e.pageX, e.pageY);
    }
  };
  
  el_svg.onmouseup = function(e) {
    touchend();
  };
  
  el_svg.onmousemove = function(e) {
    touchmove(e.pageX, e.pageY);
  };
  
  el_svg.ontouchstart = function(e) {
    if(e.target.getAttribute('class') == 'gpath' && touch.glyph == null) {
      if(e.touches.length > 0) {
        touchstart(e.target.parentElement, e.touches[0].pageX, e.touches[0].pageY);
      }
      e.preventDefault();
    }
    else {
      find_nearest_touchable(e.touches[0].pageX, e.touches[0].pageY);
    }
  };
  
  el_svg.ontouchend = function(e) {
    touchend();
    e.preventDefault();
  };
  
  el_svg.ontouchmove = function(e) {
    if(e.touches.length > 0) {
      touchmove(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  };
  
  el_pick.onclick = function() {
    el_drawer.style['bottom'] = '0vh';
    wait = 60 * 8;
  };
  
  el_show.onclick = function() {
    style_desc['opacity'] = 0.5;
  };
  
  el_hide.onclick = function() {
    style_desc['opacity'] = 0;
    wait = 1;
  };
  
  el_print.onclick = function() {
    window.print();
  };
  
  el_dictionary.onscroll = function(e) {
    wait = 60 * 8; 
  };
  
  function layout () {
    //document.querySelector('#info').textContent = window.scrollY;
    //document.querySelector('#info').textContent = innerHeight;
    el_ui.style['top'] = window.scrollY + 'px';
    rect_ui = el_ui.getBoundingClientRect();
    el_svg.setAttribute('width', innerWidth);
    el_svg.setAttribute('height', innerHeight);
    el_svg.style.left = '0px';
    el_svg.style.top = window.scrollY + 'px';
    rect_svg = el_svg.getBoundingClientRect();
    
    let aspect_ratio = innerWidth / innerHeight;
    let nw = aspect_ratio > 1.0 ? 10 : 7;
    let size = innerWidth / nw;
    base_scale = size / 300;
    let r_scale = aspect_ratio > 1.0 ? 1.0 : 10.0 / 7.0;
    
    if(aspect_ratio > 1.0) {
      style_bt_glyph['width'] = '10vh';
      style_bt_glyph['height'] = '10vh';
    }
    else {
      style_bt_glyph['width'] = '7vh';
      style_bt_glyph['height'] = '7vh';
    }
    
    let glyphs = document.querySelectorAll('.glyph');
    
    for(let i = 0; i < glyphs.length; i++) {
      let glyph = glyphs[i];
      let gpath = glyph.querySelector('.gpath');
      let bbox = gpath.getBBox();
      gpath.style.transform = `scale(${base_scale}, ${base_scale}) translate(${-bbox.width*0.5}px, ${-bbox.height*0.5}px)`;
      let rect = gpath.getBoundingClientRect();
      glyph.info.radius = Math.min(bbox.width, bbox.height) * 0.25 * r_scale;
      
      glyph.info.x = glyph.info.fx * innerWidth;
      glyph.info.y = glyph.info.fy * innerHeight;
      
      /*
      if(rect.right > rect_svg.right) {
        glyph.info.x = rect_svg.right - rect.width;
      }
      if(rect.left < rect_svg.left) {
        glyph.info.x = rect_svg.left + rect.width;
      }
      if(rect.bottom > rect_svg.bottom) {
        glyph.info.y = rect_svg.bottom - rect.height;
      }
      if(rect.top < rect_svg.top) {
        glyph.info.y = rect.height;
      }
      */
      glyph.style.transform = `translate(${glyph.info.x}px, ${glyph.info.y}px)`;
      
      let desc = glyph.querySelector('.desc');
      desc.setAttribute('transform', `translate(0, ${260 * base_scale})`);
    }
  }
  
  window.onresize = function() {
    setTimeout(layout, 500);
  };
  
  window.onload = function() {
    load_glyph_data();
    
    setTimeout(layout, 500);
    
    loop();
  };
  
  function scene_update() {
    for(let j = 0; j < ptcls.length; j++) {
      let ptcl = ptcls[j];
      for(let i = 0; i < ptcls.length; i++) {
        let other = ptcls[i];
        if(ptcl != other) {
          let dx = ptcl.info.x - other.info.x;
          let dy = ptcl.info.y - other.info.y;
          let d = Math.sqrt(dx*dx + dy*dy);
          let r = ptcl.info.radius + other.info.radius;
          if(d < r && d > 0) {
            let dr = r - d;
            let ux = dx / d;
            let uy = dy / d;
            ptcl.info.x += dr * 0.5 * ux;
            ptcl.info.y += dr * 0.5 * uy;
            ptcl.style.transform = `translate(${ptcl.info.x}px, ${ptcl.info.y}px)`;
          }
        }
      }
    }
  }
  
  function loop() {
    scene_update();
    if(wait > 0) {
      wait--;
      if(wait == 0) {
        el_drawer.style['bottom'] = '-33vh';
      }
    }
    requestAnimationFrame(loop);
  }
</script>