<!DOCTYPE html>
<meta charset="utf-8">
<title>ë¾°ì¡±ì‚°ì˜ ë³´ë¬¼</title>
<style>
    html, body {
        height: 100%;
        margin: 0;
    }
    #c {
        width: 100%;
        height: 100%;
        display: block;
    }

    #coord {
        position: absolute;
        width: 80px;
        right: 20px;
        top: 20px;
        font-family: monospace;
        font-size: 20px;
        text-shadow: 0px 0px 2px rgba(255, 255, 255, 0.5);
    }

    #coord-label {
        text-align: right;
    }

    #coord-x {
        display: inline-block;
        color: red;
        width: 60px;
        text-align: right;
    }

    #coord-y {
        display: inline-block;
        color: green;
        width: 60px;
        text-align: right;
    }

    #coord-z {
        display: inline-block;
        color: blue;
        width: 60px;
        text-align: right;
    }

    #ui {
        position: absolute;
        left: 10px;
        bottom: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 5px;
        opacity: 1;
    }
    #ui input[type=radio] {
        width: 0;
        height: 0;
        display: none;
    }
    
    #ui input[type=radio] + label {
        background-image: url('./images/flourish-cc-by-nc-sa-2.png');
        background-size: 1600% 400%;
        image-rendering: pixelated;
        width: 32px;
        height: 32px;
        display: inline-block;
    }
    #ui input[type=radio]:checked + label {
        outline: 3px solid red;
    }

    #quiz-container {
        display: none;
        position: absolute;
        left: 0px;
        top: 50px;
        width: 100%;
    }

    #quiz-panel {
        margin: auto;
        width: 800px;
        padding: 20px;
        line-height: 1.5em;
        word-break: keep-all;
        font-size: 30px;
        font-family: sans-serif;
        border-radius: 20px;
        background-color: rgba(255, 248, 219, 0.9);
    }

    #quiz-panel #quiz {
        padding-bottom: 10px;
        border-bottom: 1px solid rgb(155, 148, 119);    
    }

    #quiz-panel input[type="radio"] {
        transform: scale(2) translate(0, -2px);
    }

    #quiz-panel label {
        margin-left: 20px;
        cursor: pointer;
    }

    #quiz-panel .qtype {
        display: inline-block;
        border-radius: 10px;
        background-color: white;
        line-height: 1em;
        font-size: 16px;
        padding: 4px;
        transform: translateY(-2px);
    }

    #quiz-panel .qtype.thought {
        background-color: rgb(255, 225, 0);
    }

    #quiz-panel .qtype.sense {
        background-color: rgb(164, 242, 55);
    }

    #quiz-panel .qtype.nonsense {
        background-color: rgb(227, 146, 244);
    }

    #quiz-panel .qtype.calc {
        background-color: rgb(25, 35, 72);
        color: white;
    }

    #quiz-panel .qtype.experience {
        background-color: rgb(51, 238, 210);
    }

    #quiz-panel #by {
        text-align: right;
        font-size: 20px;
        cursor: pointer;    
    }

    #quiz-panel #quiz-result {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid rgb(155, 148, 119);    
    }

    #quiz-panel .speak-quiz, .speak-result {
        display: inline-block;
        margin-left: 10px;
        font-size: 20px;
        border-radius: 20px;
        padding: 5px;
        line-height: 1em;
        background-color: yellow;
        transform: translate(0px, -5px);
        cursor: pointer;
        user-select: none;
    }

    #quiz-panel .speak-example {
        display: inline-block;
        margin-left: 10px;
        font-size: 20px;
        border-radius: 20px;
        padding: 5px;
        line-height: 1em;
        background-color: yellow;
        transform: translate(0px, -5px) scale(-1, 1);
        cursor: pointer;
        user-select: none;
    }

    #captured {
        position: absolute;
        right: 10px;
        bottom: 10px;
        width: 520px;
        text-align: right;
    }

    .cap {
        display: inline-block;
        width: 48px;
        height: 48px;
        margin: 2px;
        border-radius: 10px;
    }

    #resume, #restart {
        display: inline-block;
        margin-left: 10px;
        padding: 8px;
        border-radius: 10px;
        border: 1px solid #818065;
        background-color: #fffca5;
        font-size: 20px;
        cursor: pointer;
        line-height: 1em;
        box-shadow: inset 2px 2px 2px rgb(255, 255, 255, 0.25), inset -2px -2px 2px rgb(0, 0, 0, 0.25);
    }
    
    @media (max-width: 600px), (max-height: 600px) {
        #ui input[type=radio] + label {
            width: 32px;
            height: 32px;
        }
    }
</style>
<body>
    <canvas id="c"></canvas>
    <div id="coord">
        <div><span class="coord-label" style="color: red">X</span><span id="coord-x">0</span></div>
        <div><span class="coord-label" style="color: green">Y</span><span id="coord-y">0</span></div>
        <div><span class="coord-label" style="color: blue">Z</span><span id="coord-z">0</span></div>
    </div>
    <div id="ui">
        <div class="tiles">
            <input type="radio" name="voxel" id="voxel1" value="1"><label for="voxel1" style="background-position:   -0% -0%"></label>
            <input type="radio" name="voxel" id="voxel2" value="2"><label for="voxel2" style="background-position: -100% -0%"></label>
            <input type="radio" name="voxel" id="voxel3" value="3"><label for="voxel3" style="background-position: -200% -0%"></label>
            <input type="radio" name="voxel" id="voxel4" value="4"><label for="voxel4" style="background-position: -300% -0%"></label>
            <input type="radio" name="voxel" id="voxel5" value="5"><label for="voxel5" style="background-position: -400% -0%"></label>
            <input type="radio" name="voxel" id="voxel6" value="6"><label for="voxel6" style="background-position: -500% -0%"></label>
            <input type="radio" name="voxel" id="voxel7" value="7"><label for="voxel7" style="background-position: -600% -0%"></label>
            <input type="radio" name="voxel" id="voxel8" value="8"><label for="voxel8" style="background-position: -700% -0%"></label>
        </div>
        <div class="tiles">
            <input type="radio" name="voxel" id="voxel9"  value="9" ><label for="voxel9"  style="background-position:  -800% -0%"></label>
            <input type="radio" name="voxel" id="voxel10" value="10"><label for="voxel10" style="background-position:  -900% -0%"></label>
            <input type="radio" name="voxel" id="voxel11" value="11"><label for="voxel11" style="background-position: -1000% -0%"></label>
            <input type="radio" name="voxel" id="voxel12" value="12"><label for="voxel12" style="background-position: -1100% -0%"></label>
            <input type="radio" name="voxel" id="voxel13" value="13"><label for="voxel13" style="background-position: -1200% -0%"></label>
            <input type="radio" name="voxel" id="voxel14" value="14"><label for="voxel14" style="background-position: -1300% -0%"></label>
            <input type="radio" name="voxel" id="voxel15" value="15"><label for="voxel15" style="background-position: -1400% -0%"></label>
            <input type="radio" name="voxel" id="voxel16" value="16"><label for="voxel16" style="background-position: -1500% -0%"></label>
        </div>
    </div>
    <div id="captured"></div>
    <div id="quiz-container">
        <div id="quiz-panel">
            <div id="quiz">ì£¼í™©ìƒ‰ì„ ë§Œë“¤ë ¤ë©´ ì–´ë–¤ ìƒ‰ì„ ì„ì–´ì•¼ í• ê¹Œìš”?</div>
            <div id="by">ê¹ŒOë°˜ ê¹€Oì›</div>
            <div>
                <input type="radio" name="example"><label>ë…¸ë‘ + íŒŒë‘</label><br>
                <input type="radio" name="example"><label>ë…¸ë‘ + ë¹¨ê°•</label><br>
                <input type="radio" name="example"><label>ë¹¨ê°• + í•˜ì–‘</label><br>
                <input type="radio" name="example"><label>ë¹¨ê°• + íŒŒë‘</label><br>
            </div>
        </div>
    </div>
</body>
<script src="./js/qnas.js"></script>
<script src="./js/tone.min.js"></script>
<script type="module">
    import * as THREE from './js/three.module.js';
    import { VoxelWorld } from './js/voxel_world.js';
    import { GLTFLoader } from './js/GLTFLoader.js';
    import { VOXLoader } from './js/VOXLoader.js';
    import { OrbitControls } from './js/OrbitControls.js';
    import { FirstPersonControls } from './js/FirstPersonControlsCustom.js';
    import { TransformControls } from './js/TransformControls.js';
    import { Physics } from './js/voxel-physics-engine.js';
    import { AABB } from './js/aabb-3d.js';
    //import * as Tone from './js/tone.min.js';
    import { josa } from './js/josa.js';
    import { Agent } from './js/agent.js';
    
    
    let cs = Array(32*32*32).fill(0).map(c => [
        Math.random(),
        Math.random(),
        Math.random(),
    ]);
    
    function main() {
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
        renderer.shadowMap.enabled = true;

        let el_coord_x = document.querySelector('#coord-x');
        let el_coord_y = document.querySelector('#coord-y');
        let el_coord_z = document.querySelector('#coord-z');
        
        const cellSize = 32;
        
        const fov = 45;
        const aspect = 2;  // the canvas default
        const near = 0.1;
        const far = 1000;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(24, 20, 21);
        camera.lookAt(24 + 1, 20, 21 + 1);
        //const orbitControls = new OrbitControls(camera, canvas);
        //orbitControls.target.set(cellSize / 2, cellSize / 3, cellSize / 2 - 1);
        //orbitControls.enabled = false;
        //orbitControls.update(0);
        const firstPersonControls = new FirstPersonControls(camera, canvas);
        firstPersonControls.fly = true;
        let controls = firstPersonControls;
        controls.update(0);
        
        const control = new TransformControls( camera, canvas );
        control.addEventListener( 'change', render );

        control.addEventListener( 'dragging-changed', function ( event ) {

            //orbitControls.enabled = ! event.value;

        } );
        
        window.controls = controls;
        window.control = control;
        window.camera = camera;

        const clock = new THREE.Clock();
        clock.start();
        window.clock = clock;

        let opts = { gravity: [0, -10, 0] }
        let getter = function(x, y, z) { 
            return world.getVoxel(x, y, z);
            //return 0;
        };

        let fluid = function(x, y, z) { 
            return 0;
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color('lightblue');
        window.scene = scene;
        window.renderer = renderer;

        let phys = new Physics(opts, getter, fluid);
        let aabb = new AABB(
            [camera.position.x, camera.position.y, camera.position.z],
            [0.6, 1.4, 0.6]
        );
        //var body = phys.addBody( aabb, mass, friction, restitution, gravityMult, onCollide )
        let body, player;
        window.phys = phys;

        let max_jump_count = 1;
        let jump_recovery = 0;
        let captured_agents = [];
        
        /*
        const box_geometry = new THREE.BoxGeometry(0.6, 1.4, 0.6);
        const box_material = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );
        const cube = new THREE.Mesh( box_geometry, box_material );
        cube.position.set(cellSize, cellSize / 3 + 5, cellSize);
        scene.add( cube );
        window.cube = cube;
        */

        let movingSpeed = 0.7;
		let ySpeed = 0;
		let acc = 0.065 / 3;
        let canJump = false;

        controls.movementSpeed = 10;
        
        const gltfLoader = new GLTFLoader();
        /*
        gltfLoader.load( './mesh/mesh_man.glb', function ( gltf ) {

            // gltf.scene.traverse( function ( child ) {

            //     if ( child.isMesh ) {

            //         roughnessMipmapper.generateMipmaps( child.material );

            //     }

            // } );

            if(gltf.scene.children.length > 0) {
                let mesh = gltf.scene.children[0];
                let mat = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    map: mesh.material.map,
                });
                mesh.material.dispose();
                mesh.material = mat;
            }

            //scene.add( gltf.scene );
            //control.attach( gltf.scene );

        } );
        */
        
		scene.add( control );
        
        const tileSize = 16;
        const tileTextureWidth = 256;
        const tileTextureHeight = 64;
        const loader = new THREE.TextureLoader();
        const texture = loader.load('./images/flourish-cc-by-nc-sa-2.png', render);
        texture.magFilter = THREE.NearestFilter;
        texture.minFilter = THREE.NearestFilter;
        
        function addLight(x, y, z) {
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(x, y, z);
            scene.add(light);
            return light;
        }
        let directional_light = addLight(1, 4, 4);
        let shadow_light = addLight(50, 40, 50);
        shadow_light.intensity = 0;;
        shadow_light.shadow.radius = 0;
        scene.add(shadow_light.target);
        shadow_light.target.position.set(50, 0, 50);
        shadow_light.castShadow = true;
        shadow_light.shadow.mapSize.width = 1024;
        shadow_light.shadow.mapSize.height = 1024;
        shadow_light.shadow.camera.top = 20;
        shadow_light.shadow.camera.bottom = -20;
        shadow_light.shadow.camera.left = -20;
        shadow_light.shadow.camera.right = 20;
        //const cameraHelper = new THREE.CameraHelper(shadow_light.shadow.camera);
        //scene.add(cameraHelper);
        window.shadow_light = shadow_light;
        //addLight( 1, -1, -2);

        const ambient_light = new THREE.AmbientLight('#ffffff', 0.75);
        scene.add(ambient_light);
        
        const world = new VoxelWorld({
            cellSize,
            tileSize,
            tileTextureWidth,
            tileTextureHeight,
        });
        
        const material = new THREE.MeshLambertMaterial({
            map: texture,
            side: THREE.DoubleSide,
            alphaTest: 0.1,
            transparent: true,
            vertexColors: true,
            wireframe: false,
        });
        
        const cellIdToMesh = {};
        function updateCellGeometry(x, y, z) {
            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const cellId = world.computeCellId(x, y, z);
            let mesh = cellIdToMesh[cellId];
            const geometry = mesh ? mesh.geometry : new THREE.BufferGeometry();
            
            const {positions, normals, colors, uvs, indices} = world.generateGeometryDataForCell(cellX, cellY, cellZ);
            const positionNumComponents = 3;
            geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
            
            const colorNumComponents = 3;
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), colorNumComponents));
            
            const normalNumComponents = 3;
            geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
            const uvNumComponents = 2;
            geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
            geometry.setIndex(indices);
            geometry.computeBoundingSphere();
            
            if (!mesh) {
                mesh = new THREE.Mesh(geometry, material);
                mesh.receiveShadow = true;
                mesh.name = cellId;
                cellIdToMesh[cellId] = mesh;
                scene.add(mesh);
                mesh.position.set(cellX * cellSize, cellY * cellSize, cellZ * cellSize);
            }
        }
        
        const neighborOffsets = [
            [ 0,  0,  0], // self
            [-1,  0,  0], // left
            [ 1,  0,  0], // right
            [ 0, -1,  0], // down
            [ 0,  1,  0], // up
            [ 0,  0, -1], // back
            [ 0,  0,  1], // front
        ];
        function updateVoxelGeometry(x, y, z) {
            const updatedCellIds = {};
            for (const offset of neighborOffsets) {
                const ox = x + offset[0];
                const oy = y + offset[1];
                const oz = z + offset[2];
                const cellId = world.computeCellId(ox, oy, oz);
                if (!updatedCellIds[cellId]) {
                    updatedCellIds[cellId] = true;
                    updateCellGeometry(ox, oy, oz);
                }
            }
        }

        /*
        for (let y = 0; y < cellSize; ++y) {
            for (let z = 0; z < cellSize; ++z) {
                for (let x = 0; x < cellSize; ++x) {
                    const height = (Math.sin(x / cellSize * Math.PI * 2) + Math.sin(z / cellSize * Math.PI * 3)) * (cellSize / 6) + (cellSize / 2);
                    if (y < height) {
                        //world.setVoxel(x, y, z, randInt(1, 17));
                        world.setVoxel(x, y, z, 14);
                    }
                }
            }
        }
        */

        /*
        for (let y = 0; y < 2; ++y) {
            for (let z = 0; z < cellSize; ++z) {
                for (let x = 0; x < cellSize; ++x) {
                    world.setVoxel(x, y - 2, z, 4);
                }
            }
        }
        */

        function load_vox_chunks(chunks) {
            window.chunks = chunks;
            for ( let i = 0; i < chunks.length; i ++ ) {

                const chunk = chunks[ i ];

                let palette = chunk.palette;
                window.palette = palette;
                let data = chunk.data;

                for ( let j = 0; j < data.length; j += 4 ) {

                    const x = data[ j + 0 ];
                    const y = data[ j + 1 ];
                    const z = data[ j + 2 ];
                    const c = data[ j + 3 ];

                    const hex = palette[ c ];
                    const r = ( hex >> 0 & 0xff ) / 0xff;
                    const g = ( hex >> 8 & 0xff ) / 0xff;
                    const b = ( hex >> 16 & 0xff ) / 0xff;

                    if ( r > 0 || g > 0 || b > 0 ) {
                        world.setVoxel(x, z, chunk.size.y - y, 100 + c); 
                    }
                    else {
                        world.setVoxel(x, z, chunk.size.y - y, 5);
                    }
                }
            }

            for(let cid in world.cells) {
                let id = cid.split(',').map(n => parseInt(n * cellSize));
                updateCellGeometry(...id);
            }

            glbs = glbs.splice(0, qnas.length + 1);
            glbs.forEach(x => load_agent('./mesh/' + x));

            body = phys.addBody(aabb, 1, 0.25, 0, 2, null);
            player = {
                body: body,
                getPosition() {
                return [
                        this.body.aabb.base[0] + this.body.aabb.vec[0]*0.5,
                        this.body.aabb.base[1] + this.body.aabb.vec[1]*0.5,
                        this.body.aabb.base[2] + this.body.aabb.vec[2]*0.5
                    ];
                }
            };
            window.player = player;
        }

        const vox_loader = new VOXLoader();
        vox_loader.load( './vox/test_island.vox', load_vox_chunks);
        firstPersonControls.fly = false;

        //-----

        let agents = [];
        window.agents = agents;

        function load_agent(url) {
            gltfLoader.load( url, function ( gltf ) {

                if(gltf.scene.children.length > 0) {
                    
                    let mesh = gltf.scene.children[0];
                    let image = mesh.material.map.image;
                    let ctx = document.createElement('canvas').getContext('2d');
                    ctx.canvas.width = image.width;
                    ctx.canvas.height = image.height;
                    ctx.drawImage(image, 0, 0);
                    let texture = new THREE.CanvasTexture( ctx.canvas );
                    texture.flipY = false;

                    let mat = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: 0x282828,
                        //map: mesh.material.map,
                        map: texture,
                    });
                    mesh.castShadow = true;
                    mesh.material.dispose();
                    mesh.material = mat;

                    scene.add(mesh);

                    let agent = new Agent(mesh, agents, world, phys, player);
                    agent.name = url.split('/').pop().split('.')[0];
                    agent.className = url.split('/')[2];
                    agent.ctx = ctx;
                    // agent.setPosition(
                    //     cellSize + (Math.random()*2-1) * 5,
                    //     cellSize / 3 + 5,
                    //     cellSize + (Math.random()*2-1) * 5);
                    agent.setPosition(
                        40 + (Math.random()*2-1) * 15,
                        10 + Math.random() * 10,
                        40 + (Math.random()*2-1) * 15);
                    agents.push(agent);
                }
            } );
        }

        shuffle(_qnas);
        let qnas = JSON.parse(JSON.stringify(_qnas)).splice(0, 20);
        qnas = qnas.sort((a, b) => (new Date(b.date)) - new Date(a.date));

        let glbs = [
            'ê¹Œì¹˜ë°˜/ê¶Œë¼ë‚˜.glb',
            'ê¹Œì¹˜ë°˜/ê¹€ì‹œì›.glb',
            'ê¹Œì¹˜ë°˜/ì†ìŠ¹ìš°.glb',
            'ê¹Œì¹˜ë°˜/ì•ˆì¬ì¤€.glb',
            'ê¹Œì¹˜ë°˜/ìµœì§€ìœ _ë¯¸ìƒì´.glb',
            'ì¢…ë‹¬ìƒˆë°˜/ê¹€ì±„ì€.glb',
            'ì¢…ë‹¬ìƒˆë°˜/ì´ì§€ì›.glb',
            'ì¢…ë‹¬ìƒˆë°˜/ì „í•„ë¦½.glb',
            'ì¢…ë‹¬ìƒˆë°˜/ì •ì˜ˆì€.glb',
            'ì¢…ë‹¬ìƒˆë°˜/ìµœí˜„ìœ¨.glb',
            'ì†Œë‚˜ë¬´ë°˜/ê¹€ì§€ìœ .glb',
            'ì†Œë‚˜ë¬´ë°˜/ë°•ê±´.glb',
            'ì†Œë‚˜ë¬´ë°˜/ì„ì±„ì€.glb',
            'ì†Œë‚˜ë¬´ë°˜/ì •ìœ ì¤€.glb',
            'ì†Œë‚˜ë¬´ë°˜/í™ì±„ì€.glb',
            'ì°¸ë‚˜ë¬´ë°˜/ì´ì°¬ì˜_í†µí†µì–´ëª½ì–´ìŠ¤.glb',
            'ì°¸ë‚˜ë¬´ë°˜/ì •í˜„ì¡°_ë¦¬ì„ëª¬ìŠ¤í„°.glb',
            'ì°¸ë‚˜ë¬´ë°˜/íƒœí˜„ìš°_ì¿ ì¿ ë‹¤ì´ë…¸.glb',
            'í•´ë°”ë¼ê¸°ë°˜/ê¹€ì„¸í•˜_í•˜íŠ¸ê½ƒ.glb',
            'í•´ë°”ë¼ê¸°ë°˜/ê¹€íƒœê±´_ì½”ì•Œë¼.glb',
            'í•´ë°”ë¼ê¸°ë°˜/ë‚¨ì£¼ì—˜_ê³°ëŒì´í’ì„ .glb',
            'í•´ë°”ë¼ê¸°ë°˜/ì´ì‹œì•„_ê½ƒê²Œ.glb',
            'ì§„ë‹¬ë˜ë°˜/ê¶Œì´ì¤€.glb',
            'ì§„ë‹¬ë˜ë°˜/ê¹€ë´„.glb',
            'ì§„ë‹¬ë˜ë°˜/ì°¨ì§€ìœ¤.glb',
            'ê°œë‚˜ë¦¬ë°˜/ê¹€ì§€ì™„_ê³ ë˜.glb',
            'ê°œë‚˜ë¦¬ë°˜/ê¹€íƒœë¦¼_ìœ ë‹ˆì½˜.glb',
            'ê°œë‚˜ë¦¬ë°˜/ê¹€í•˜ì—˜_ì—„ë§ˆí† ë¼.glb',
            'ê°œë‚˜ë¦¬ë°˜/ìœ ì´ì˜¨_íŠœë‹™.glb',
            'ê°œë‚˜ë¦¬ë°˜/ì´ë‹¤ìœ¤_ìƒì–´.glb'
        ];
        shuffle(glbs);

        // for(let g of glbs) {
        //     console.log(g.split(''))
        // }

        // glbs = glbs.splice(0, qnas.length + 1);
        // glbs.forEach(x => load_agent('./mesh/' + x));

        //-----

        let synth = null;
        let utter = new SpeechSynthesisUtterance();
        utter.lang = 'ko';
        window.utter = utter;
        let curr_quiz = null;
        let curr_answer = [];
        window.doing_quiz = false;
        window.curr_agent = null;
        let is_speaking = false;

        utter.addEventListener('start', (e) => {
            is_speaking = true;
        });

        utter.addEventListener('end', (e) => {
            is_speaking = false;
        });

        window.addEventListener('storage', (e) => {
            if(e.key === 'vox') {
                let content = Uint8Array.from(localStorage['vox'].split(','));
                let chunks = vox_loader.parse(content.buffer);
                load_vox_chunks(chunks);
            }
        });
        
        function randInt(min, max) {
            return Math.floor(Math.random() * (max - min) + min);
        }
        
        //updateVoxelGeometry(1, 1, 1);  // 0,0,0 will generate
        for(let cid in world.cells) {
            let id = cid.split(',').map(n => parseInt(n * cellSize));
            updateCellGeometry(...id);
        }

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;

            if (needResize) {
                renderer.setSize(width, height, false);
            }
            return needResize;
        }
        
        let renderRequested = false;
        
        function render(delta) {
            //renderRequested = undefined;
            
            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            }

            renderer.render(scene, camera);
        }

        function _intersect(x1, y1, z1, w1, h1, d1, x2, y2, z2, w2, h2, d2){
			let a = {
				minX : x1 - (w1/2),
				maxX : x1 + (w1/2),
				minZ : z1 - (d1/2),
				maxZ : z1 + (d1/2),
				minY : y1 - (h1/2),
				maxY : y1 + (h1/2),
			};
			let b = {
				minX : x2 - (w2/2),
				maxX : x2 + (w2/2),
				minZ : z2 - (d2/2),
				maxZ : z2 + (d2/2),
				minY : y2 - (h2/2),
				maxY : y2 + (h2/2),
			};
			return (a.minX <= b.maxX && a.maxX >= b.minX) &&
		           (a.minY <= b.maxY && a.maxY >= b.minY) &&
		           (a.minZ <= b.maxZ && a.maxZ >= b.minZ);
		}

        let signs = [-1, 0, 1];
        function update(delta) {
            if(!player) return;

            let time = performance.now() * 0.001;

            if(!firstPersonControls.fly) {
                for(let agent of agents) {
                    agent.update(time);
                }
                

                //------------

                let f_speed = 0;
                let r_speed = 0;
                let speed = delta * controls.movementSpeed;

                //let vf = firstPersonControls.getForwardVector();
                //let vr = firstPersonControls.getRightVector();
                //console.log(vf, vr);
                let vf = new THREE.Vector3();
                let vr = new THREE.Vector3();

                if(firstPersonControls.moveForward) {
                    vf.copy(firstPersonControls.getForwardVector());
                    f_speed += speed;
                }
                if(firstPersonControls.moveBackward) {
                    vf.copy(firstPersonControls.getForwardVector());
                    f_speed += -speed;
                }
                if(firstPersonControls.moveLeft) {
                    vr.copy(firstPersonControls.getRightVector());
                    r_speed += -speed;
                }
                if(firstPersonControls.moveRight) {
                    vr.copy(firstPersonControls.getRightVector());
                    r_speed += speed;
                }

                let v = vf.clone().multiplyScalar(f_speed).add(vr.multiplyScalar(r_speed));

                body.applyForce([v.x * 35, 0, v.z * 35]);
                //body.applyImpulse([v.x * 1, 0, v.z * 1]);
                
                //phys.tick( delta * 1000 );
                //phys.tick( 33.3333 );
                if(!window.doing_quiz) {
                    phys.tick( 24 );    
                }

                let pos = body.getPosition();
                camera.position.x = pos[0] + 0.3;
                camera.position.y = pos[1] + 1.4;
                camera.position.z = pos[2] + 0.3;

                if(pos[1] < -10) {
                    body.setPosition([24, 20, 21]);
                }

                shadow_light.position.set(pos[0], 100, pos[2]);
                shadow_light.target.position.set(pos[0], -100, pos[2]);

                el_coord_x.textContent = `${pos[0] | 0}`;
                el_coord_y.textContent = `${pos[1] | 0}`;
                el_coord_z.textContent = `${pos[2] | 0}`;
            }

            controls.update(delta);
        }
        
        function requestRenderIfNotRequested() {
            if (!renderRequested) {
                renderRequested = true;
                requestAnimationFrame(render);
            }
        }
        
        let currentVoxel = 0;
        let currentId;
        
        document.querySelectorAll('#ui .tiles input[type=radio][name=voxel]').forEach((elem) => {
            elem.addEventListener('click', allowUncheck);
        });
        
        function allowUncheck() {
            if (this.id === currentId) {
                this.checked = false;
                currentId = undefined;
                currentVoxel = 0;
            } else {
                currentId = this.id;
                currentVoxel = parseInt(this.value);
            }
        }
        
        function getCanvasRelativePosition(event) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (event.clientX - rect.left) * canvas.width  / rect.width,
                y: (event.clientY - rect.top ) * canvas.height / rect.height,
            };
        }
        
        function placeVoxel(event) {
            const pos = getCanvasRelativePosition(event);
            const x = (pos.x / canvas.width ) *  2 - 1;
            const y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y
            
            const start = new THREE.Vector3();
            const end = new THREE.Vector3();
            start.setFromMatrixPosition(camera.matrixWorld);
            end.set(x, y, 1).unproject(camera);
            
            const intersection = world.intersectRay(start, end);
            if (intersection) {
                const voxelId = event.shiftKey ? 0 : currentVoxel;
                // the intersection point is on the face. That means
                // the math imprecision could put us on either side of the face.
                // so go half a normal into the voxel if removing (currentVoxel = 0)
                // our out of the voxel if adding (currentVoxel  > 0)
                const pos = intersection.position.map((v, ndx) => {
                    return v + intersection.normal[ndx] * (voxelId > 0 ? 0.5 : -0.5);
                });
                world.setVoxel(...pos, voxelId);
                updateVoxelGeometry(...pos);
                requestRenderIfNotRequested();
            }
        }
        
        const mouse = {
            x: 0,
            y: 0,
        };
        
        function recordStartPosition(event) {
            mouse.x = event.clientX;
            mouse.y = event.clientY;
            mouse.moveX = 0;
            mouse.moveY = 0;
        }
        function recordMovement(event) {
            mouse.moveX += Math.abs(mouse.x - event.clientX);
            mouse.moveY += Math.abs(mouse.y - event.clientY);
        }
        function placeVoxelIfNoMovement(event) {
            if (mouse.moveX < 5 && mouse.moveY < 5) {
                placeVoxel(event);
            }
            window.removeEventListener('pointermove', recordMovement);
            window.removeEventListener('pointerup', placeVoxelIfNoMovement);
        }
        
        canvas.addEventListener('pointerdown', (event) => {
            //event.preventDefault();
            recordStartPosition(event);
            window.addEventListener('pointermove', recordMovement);
            window.addEventListener('pointerup', placeVoxelIfNoMovement);
        }, {passive: false});
        
        let touch = {
            startX: 0,
            startY: 0,
            oldX: 0,
            oldY: 0,
            moveX: 0,
            moveY: 0,
        };

        canvas.addEventListener('touchstart', (event) => {
            if(!synth) {
                synth = new Tone.Synth().toDestination();
                window.synth = synth;
            }
            if(event.touches[0]) {
                touch.startX = event.touches[0].pageX;
                touch.startY = event.touches[0].pageY;
                touch.oldX = touch.startX;
                touch.oldY = touch.startY;
                touch.moveX = touch.startX;
                touch.moveY = touch.startY;
                if(touch.startY / window.innerHeight > 0.8) {
                    if(canJump) {
                        if(jump_recovery === 0) {
                            body.applyImpulse([0, 9, 0]);
                        }
                        canJump = false;
                    }
                }
            }
            // prevent scrolling
            event.preventDefault();
        }, {passive: false});

        canvas.addEventListener('touchend', (event) => {
            canJump = true;
            jump_recovery = Math.max(20 - captured_agents.length, 0);

            firstPersonControls.viewLeft = false;
            firstPersonControls.viewRight = false;
            firstPersonControls.moveForward = false;
            firstPersonControls.moveBackward = false;

            // prevent scrolling
            event.preventDefault();
        }, {passive: false});

        canvas.addEventListener('touchmove', (event) => {
            //console.log(event);
            if(event.touches[0]) {
                touch.oldX = touch.moveX;
                touch.oldY = touch.moveY;
                touch.moveX = event.touches[0].pageX;
                touch.moveY = event.touches[0].pageY;
                let dx = touch.moveX - touch.oldX;
                let dy = touch.moveY - touch.oldY;
                if(Math.abs(dx) > 20) {
                    if(dx < 0) {
                        firstPersonControls.viewLeft = true;
                    }
                    else if(dx > 0) {
                        firstPersonControls.viewRight = true;
                    }
                }
                if(Math.abs(dy) > 1) {
                    if(dy < 0) {
                        firstPersonControls.moveForward = true;
                    }
                    else if(dy > 0) {
                        firstPersonControls.moveBackward = true;
                    }       
                }
            }
            event.preventDefault();
        }, {passive: false});
        
        //controls.addEventListener('change', requestRenderIfNotRequested);
        window.addEventListener('resize', requestRenderIfNotRequested);

        document.body.addEventListener("click", function() {
			//controls.lock();
        });

        document.addEventListener("keydown", function(e) {
            if(!synth) {
                synth = new Tone.Synth().toDestination();
                window.synth = synth;
            }

			if(e.code == 'Space') {
                if(canJump) {
                    if(jump_recovery === 0) {
                        body.applyImpulse([0, 9, 0]);
                    }
                    canJump = false;
                }
		    }
        });

        function shuffle(array) {
            let n = array.length, t, i;
            while (n) {
                i = Math.random() * n-- | 0; // 0 â‰¤ i < n
                t = array[n];
                array[n] = array[i];
                array[i] = t;
            }
            return array;
        }

        document.addEventListener("keyup", function(e) {
            //console.log(e.code);
            if(e.code == 'Space') {
                canJump = true;
                jump_recovery = Math.max(20 - captured_agents.length, 0);
		    }
            
            if(e.code === 'Digit1') {
                //changeToFirstPerson();
                //do_quiz();
            }

            if(e.code === 'Digit2') {
                //changeToOrbit();
                //document.querySelector('#quiz-container').style.display = 'none';
            }

			if(e.code === 'Enter') {
                if(firstPersonControls.fly === true) {
                    body.setPosition([
                        camera.position.x - 0.3,
                        camera.position.y - 1.4,
                        camera.position.z - 0.3,
                    ]);
                }
                //firstPersonControls.fly = !firstPersonControls.fly;
            }
        });

        function changeToOrbit() {
            firstPersonControls.fly = false;
            orbitControls.enabled = true;
            firstPersonControls.enabled = false;
            //orbitControls.target.copy(firstPersonControls.targetPos);
            orbitControls.target.copy(control.object.position);
            controls = orbitControls;
        }
        window.changeToOrbit = changeToOrbit;

        function changeToFirstPerson() {
            firstPersonControls.fly = true;
            orbitControls.enabled = false;
            firstPersonControls.enabled = true;
            controls = firstPersonControls;
        }
        window.changeToFirstPerson = changeToFirstPerson;

        function do_quiz() {
            if(qnas.length > 0) {
                synth.triggerAttackRelease("C4", "8n");

                let q = qnas[0];
                if(curr_agent) {
                    let by_name = curr_agent.name.split('_')[0];
                    let by_quiz_list = qnas.filter(qu => qu.by === by_name);
                    if(by_quiz_list.length > 0) {
                        q = by_quiz_list[by_quiz_list.length * Math.random() | 0];
                    }
                }
                curr_quiz = q;
                curr_answer = q.answer;
                if(q.year === 3) {
                    utter.rate = 0.8;
                }
                else {
                    utter.rate = 1;
                }
                if(q.lang_quiz !== 'ko') {
                    utter.rate = 0.8;
                }
                let by = q.by;
                if(by !== 'ì–´ë¦°ì´ë“¤') {
                    let _by = by.split('');
                    for(let i = 0; i < _by.length; i++) {
                        if(i > 0 && i < _by.length - 1) {
                            _by[i] = 'O';
                        }
                    }
                    if(_by.length === 2) {
                        _by[1] = 'O';
                    }
                    by = _by.join('');
                }
                by = q.class + ' ' + by;
                if(q.role !== 'ì–´ë¦°ì´') {
                    by += ' ' + q.role;
                }
                let list = [];
                list = list.concat(q.answer, q.example);
                shuffle(list);
                let examples = '';
                for(let li of list) {
                    examples += `<div>
                        <input type="radio" name="example" value="${li}">
                        <label class="example">${li}</label>
                        <span class="speak-example">ğŸ“¢</span>
                    </div>`;
                }

                let en_type = {
                    'ìƒê°': 'thought',
                    'ìƒì‹': 'sense',
                    'ì—‰ëš±': 'nonsense',
                    'ìˆ«ì': 'calc',
                    'ì¼ìƒ': 'experience'
                };

                let types = q.type.map(x => {
                    return `<span class="qtype ${en_type[x]}">${x}</span>`;    
                }).join(', ');
                
                let quiz_signs = 'ğŸ’­,ğŸ”,ğŸ–ï¸'.split(',');
                let quiz_sign = quiz_signs[quiz_signs.length * Math.random() | 0];
                let template = `<div id="quiz-panel">
                    <div id="quiz"><span>${quiz_sign}</span> <span id="quiz-text">${q.quiz}</span><span class="speak-quiz">ğŸ“¢</span></div>
                    <div id="by">
                        <span id="by-name">${by}</span><span>ì˜ ${types} ìˆ˜ìˆ˜ê»˜ë¼</span>
                    </div>
                    <div id="examples">${examples}</div>
                    <div id="quiz-result" style="display: none">
                        <span id="result-sign"></span>
                        <span id="quiz-result-body"></span>
                        <span class="speak-result">ğŸ“¢</span>
                        <div style="text-align: right"><div id="resume">ì´ì–´ì„œ í”Œë ˆì´</div></div>
                    </div>
                </div>`;
                document.querySelector('#quiz-container').innerHTML = template;
                document.querySelector('#quiz-container').style.display = 'block';
            }
            else {
                let template = `<div id="quiz-panel">
                    <div>ğŸ‰ ì˜¤ëŠ˜ì˜ ìˆ˜ìˆ˜ê»˜ë¼ë¥¼ ëª¨ë‘ í’€ì—ˆìŠµë‹ˆë‹¤! <br>ì¶•í•˜í•©ë‹ˆë‹¤~ <br>ì˜¤ëŠ˜ì€ ì—¬ê¸°ê¹Œì§€ í•˜ê¸°ë¡œ í•´ìš”!</div>
                    <div style="text-align: right"><div id="resume">ì´ì–´ì„œ í”Œë ˆì´</div><div id="restart">ëª¨ë“  ê·¸ë¦¼ì´ë¥¼ ë‹¤ì‹œ ë†“ì•„ì£¼ê¸°</div></div>
                </div>`;
                document.querySelector('#quiz-container').innerHTML = template;
                document.querySelector('#quiz-container').style.display = 'block';
            }
            
        }
        window.do_quiz = do_quiz;
        window.until_quiz = 120;
        let run_exprs = `
            ì½§ë°©ê·€ë¥¼ ë€Œë©´ì„œ
            ë¯¸ì•ˆí•´í•˜ë©´ì„œ
            í•˜í•˜ ì›ƒìœ¼ë©´ì„œ
            ë©”ë¡± ë†€ë¦¬ë©´ì„œ
            ê¹Œë¶ˆê¹Œë¶ˆ ì¥ë‚œì¹˜ë©´ì„œ
            ì¦ê²ê²Œ
            ê¸°ìš´ì°¨ê²Œ
            í™œê¸°ì°¨ê²Œ
            ì‘¥ì“°ëŸ¬ì›Œí•˜ë©´ì„œ
            ì•„ì‰¬ì›Œí•˜ë©´ì„œ
            ë‹¤ìŒ ë§Œë‚¨ì„ ê¸°ëŒ€í•˜ë©´ì„œ
            ì¬ë¹ ë¥´ê²Œ
            ë¨¸ì“±í•´ í•˜ë©´ì„œ
            í‘¸í•˜í•˜ ì›ƒìœ¼ë©´ì„œ
            í˜¸í˜¸ ì›ƒìœ¼ë©´ì„œ
            ê¹”ê¹”ê¹” ì›ƒìœ¼ë©°
            êº„ë¥´ë¥´ ë°°ê¼½ì¡ê³  ì›ƒìœ¼ë©°
            í˜ë‚´ë¼ê³  ì‘ì›í•˜ë©´ì„œ
            ìˆ˜ì¤ì–´í•˜ë©´ì„œ
            ë§¤ëª°ì°¨ê²Œ
            ìƒëƒ¥í•˜ê²Œ
            ë‹¤ìŒì— ë˜ ë³´ìë©°
            ë£°ë£¨ í¥ì–¼ê±°ë¦¬ë©°
            ê³ ê°œë¥¼ ê°¸ì›ƒê±°ë¦¬ë©°
            íœ˜ë¦¬ë¦­
            ìŒ”ì•µ
            ë¿…
            ìš°ë‹¹íƒ•ì¿µì¾…
            ìš”ë¦¬ì¡°ë¦¬
            íœ˜íŒŒëŒì„ ë¶ˆë©´ì„œ
            ì‚´ê¸ˆì‚´ê¸ˆ
            í„ì©í„ì© ë›°ì–´ê°€ë©°
            ê¹¡ì´ê¹¡ì´ ë›°ë©°
            ì‚¬ë¿ì‚¬ë¿ ì•„ë¦„ë‹µê²Œ
            í›„ë‹¤ë‹¤ë‹¥
            ì˜¤ ë§ˆì´ ê°“! í•˜ë©°
            ì í”„!ì í”„!í•˜ë©´ì„œ
            íœ˜ì íœ˜ì 
            ì¬ë¹ ë¥´ê³  ì•„ë¦„ë‹µê²Œ
            ë°êµ´ë°êµ´ êµ´ëŸ¬ê°€ë©°
            êµ¬ë¦„ ìœ„ë¥¼ ë‚ ë“¯ ë›°ì–´ì„œ
        `.split('\n').map(x => x.trim()).filter(x => x.length > 0);

        let reunion_exprs = `
            ìƒë— ì›ƒìœ¼ë©°
            ë°˜ê°€ì›Œí•˜ë©´ì„œ
            ë©‹ì ì–´í•˜ë©´ì„œ
            ê¸°ë¶„ ì¢‹ê²Œ
            ë°°ì‹œì‹œ ì›ƒìœ¼ë©°
            ë¹™ê¸‹ ì›ƒìœ¼ë©°
            ë°©ê¸‹ ì›ƒìœ¼ë©°
            ê¹”ê¹”ê¹” ì›ƒìœ¼ë©°
            ì”©ì”©í•˜ê²Œ
            ê³°ê³°íˆ ìƒê°í•˜ë©´ì„œ
            ê¹¡ì´ê¹¡ì´ ë›°ë©´ì„œ
            ì–´ìŠ¬ë ê±°ë¦¬ë©°
            ê°ˆíŒ¡ì§ˆíŒ¡í•˜ë©´ì„œ
            ê¹¡ì´ê¹¡ì´ ë›°ë©°
            ë‹¤ì‹œ ë„ë§ê°ˆê¹Œí•˜ë‹¤ê°€
            ì½§ë…¸ë˜ë¥¼ í¥ì–¼ê±°ë¦¬ë©°
            ë…¸ë˜ë¶€ë¥´ë©°
            ì¬ì±„ê¸°í•˜ë©´ì„œ
            ëˆˆë¬¼ì„ ê¸€ì½ì´ë©°
            í•˜í’ˆí•˜ë©´ì„œ
            ì¸ì‚¬í•˜ë©´ì„œ
            í•¨ë°•ì›ƒìŒ ì§€ìœ¼ë©°
            ì…ì„ ë¹„ì£½ì´ë©°
            ìš©ê¸°ë‚´ì„œ
            ë¶€ë„ëŸ¬ì›Œí•˜ë©´ì„œ
            ìˆ˜ì¤ì–´í•˜ë©´ì„œ
            ì–´ë µì‚¬ë¦¬
            ìœ™í¬í•˜ë©´ì„œ
            ì‚¬ë¿ì‚¬ë¿ ì•„ë¦„ë‹µê²Œ
            ì˜¤ì¼€ì´! í•˜ë©°
            ì˜¤ì˜ˆ! í•˜ë©°
            íšŒì˜¤ë¦¬ëŒë©´ì„œ
            í–‰ë³µí•´í•˜ë©´ì„œ
        `.split('\n').map(x => x.trim()).filter(x => x.length > 0);

        function check_answer(answer) {
            if(!document.querySelector('#examples')) return;

            let inputs = document.querySelector('#examples').querySelectorAll('input[type="radio"]');
            for(let item of inputs) {
                item.setAttribute('disabled', true);
            }
            let by = document.querySelector('#by-name').textContent;
            let result_sign = '';
            
            let O = 'â˜ºï¸,â¤ï¸,ğŸ’¡,âœ¨,ğŸ‘,ğŸ˜‰'.split(',');
            let X = 'ğŸ¤”,â˜”,ğŸ’­,ğŸƒ,ğŸŒˆ,ğŸ’«'.split(',');
            let R = 'ğŸ’¨,ğŸˆ,ğŸƒâ€â™€ï¸,ğŸƒâ€â™‚ï¸,ğŸ¦‹'.split(',');
            let F = 'ğŸ‘€,ğŸ“·,ğŸ‘‹,ğŸ•µï¸,ğŸ‘«'.split(',');
            let H = 'ğŸ¤—,ğŸ’–,ğŸ ,ğŸ“–,ğŸµ'.split(',');

            let html = '';
            if(curr_answer.includes(answer)) {
                const now = Tone.now()
                synth.triggerAttackRelease("C4", "8n", now);
                synth.triggerAttackRelease("E4", "8n", now + 0.25);
                synth.triggerAttackRelease("G4", "8n", now + 0.5);

                let found = F[Math.random() * F.length | 0];
                let home = H[Math.random() * H.length | 0];

                html = `<span class="text">${by}ë„ ê·¸ë ‡ê²Œ ìƒê°í•œë°ìš”.</span><br>
                    <span>${found}</span> <span class="text">ê·¸ë¦¼ì´ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!</span>`;
                let expr = reunion_exprs[Math.random() * reunion_exprs.length | 0];
                if(curr_agent) {
                    let [owner, a_name] = curr_agent.name.split('_');
                    let _owner = owner.split('');
                    _owner[_owner.length - 2] = 'O';
                    owner = _owner.join('');
                    let owner_1 = owner + josa.c(owner, 'ì´/ê°€');
                    if(a_name) {
                        let hsl = `hsl(${Math.random()*360|0},100%,40%)`;
                        let a_name_1 = `<span style="color: ${hsl}; font-weight: bold">${a_name}</span>` + josa.c(a_name, 'ì„/ë¥¼');
                        let a_name_2 = `<span style="color: ${hsl}; font-weight: bold">${a_name}</span>` + josa.c(a_name, 'ì´/ê°€');
                        html = `<span class="text"> ${by}ë„ ê·¸ë ‡ê²Œ ìƒê°í•œë°ìš”.</span><br>
                            <span>${found}</span> <span class="text">${owner_1} ê·¸ë¦° ${a_name_1} ì°¾ì•˜ìŠµë‹ˆë‹¤!</span><br>
                            <span>${home}</span> <span class="text">${a_name_2} <span style="color: purple; font-weight: bold">${expr}</span> ëŒì•„ì˜µë‹ˆë‹¤.</span>`;
                    }
                    else {
                        html = `<span class="text">${by}ë„ ê·¸ë ‡ê²Œ ìƒê°í•œë°ìš”.</span><br>
                            <span>${found}</span> <span class="text">${owner_1} ê·¸ë¦° ê·¸ë¦¼ì´ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤!</span><br>
                            <span>${home}</span> <span class="text">ê·¸ë¦¼ì´ê°€ <span style="color: purple; font-weight: bold">${expr}</span> ëŒì•„ì˜µë‹ˆë‹¤.</span>`;
                    }
                }
                result_sign = O[Math.random() * O.length | 0];
                
                // ë§ì¶˜ ìˆ˜ìˆ˜ê»˜ë¼ í•˜ë‚˜ ë¹¼ê¸°
                let idx_curr_quiz = qnas.indexOf(curr_quiz);
                if(idx_curr_quiz != -1) {
                    qnas.splice(idx_curr_quiz, 1);
                }
                
                // ì¡ì•˜ë‹¤!
                if(curr_agent) {
                    let img = new Image();
                    img.className = 'cap';
                    img.src = curr_agent.ctx.canvas.toDataURL();
                    document.querySelector('#captured').appendChild(img);
                    
                    body.applyImpulse([-body.velocity[0], -body.velocity[1], -body.velocity[2]]);
                    scene.remove(curr_agent.mesh);
                    let idx = phys.bodies.indexOf(curr_agent.body);
                    if(idx !== -1) {
                        phys.bodies.splice(idx, 1);
                    }
                    idx = agents.indexOf(curr_agent);
                    if(idx !== -1) {
                        captured_agents.push(agents[idx]);
                        agents.splice(idx, 1);
                    }
                    curr_agent = null;
                }
            }
            else {
                synth.triggerAttackRelease("G4", "8n");

                let expr = run_exprs[Math.random() * run_exprs.length | 0];
                html = `<span class="text">${by}ì˜ ìƒê°ì€ ë‹¬ëì–´ìš”.</span><br>
                    <span>${R[Math.random() * R.length | 0]}</span> <span class="text">ê·¸ë¦¼ì´ê°€ <span style="color: purple; font-weight: bold">${expr}</span> ë„ë§ê°‘ë‹ˆë‹¤!</span>`;
                result_sign = X[Math.random() * X.length | 0];
                if(curr_agent) {
                    curr_agent.body.applyImpulse([(Math.random()*2-1), 10, (Math.random()*2-1)]);
                    body.applyImpulse([(Math.random()*2-1)*2, 5, (Math.random()*2-1)*2]);
                }
                curr_agent = null;
            }
            document.querySelector('#quiz-result-body').innerHTML = html;
            document.querySelector('#result-sign').textContent = result_sign;
            document.querySelector('#quiz-result').style.display = 'block';
        }

        window.addEventListener('input', (e) => {
            if(e.target.name === 'example') {
                check_answer(e.target.value);    
            }
        });

        window.addEventListener('click', (e) => {
            if(e.target.className === 'example') {
                let text = e.target.parentElement.querySelector('input').value;
                if(!e.target.parentElement.querySelector('input').disabled) {
                    e.target.parentElement.querySelector('input').checked = true;
                    check_answer(text);
                }
            }

            if(e.target.className === 'speak-quiz') {
                if(doing_quiz) {
                    utter.text = document.querySelector('#quiz-text').textContent;
                    if(!is_speaking) {
                        utter.lang = curr_quiz.lang_quiz;
                        speechSynthesis.speak(utter);
                    }
                }
            }

            if(e.target.className === 'speak-result') {
                if(doing_quiz) {
                    let texts = Array.prototype.slice.call(document.querySelector('#quiz-result-body').querySelectorAll('.text')).map(x => x.textContent);
                    utter.text = texts.join(' ');
                    //let tan = 'ë•¡,ê½,í¥,ì‚'.split(',');
                    //utter.text = utter.text.replaceAll('O', tan[Math.random() * tan.length | 0]);
                    if(!is_speaking) {
                        utter.text = utter.text.replaceAll('O', '');
                        utter.lang = 'ko';
                        speechSynthesis.speak(utter);
                    }
                }
            }

            if(e.target.parentElement.id === 'by' || e.target.parentElement.parentElement.id === 'by') {
                if(doing_quiz) {
                    utter.text = document.querySelector('#by').textContent;
                    utter.text = utter.text.replaceAll('O', ' ');
                    if(!is_speaking) {
                        utter.lang = 'ko';
                        speechSynthesis.speak(utter);
                    }
                }
            }

            if(e.target.className === 'speak-example') {
                if(doing_quiz) {
                    let text = e.target.parentElement.querySelector('input').value;
                    let emoji_regex = /\p{Extended_Pictographic}/ug;
                    if(emoji_regex.test(text)) {
                        let txt = text.split(' ');
                        txt.pop();
                        utter.text = txt.join(' ');
                    }
                    else {
                        utter.text = text;
                    }
                    if(!is_speaking) {
                        utter.lang = curr_quiz.lang_answer;
                        speechSynthesis.speak(utter);
                    }
                }
            }

            if(e.target.id === 'resume') {
                doing_quiz = false;
                document.querySelector('#quiz-container').style.display = 'none';
                window.until_quiz = 300;
            }

            if(e.target.id === 'restart') {
                doing_quiz = false;
                window.until_quiz = 300;
                document.querySelector('#quiz-container').style.display = 'none';
                shuffle(_qnas);
                qnas = JSON.parse(JSON.stringify(_qnas)).splice(0, 20);
                while(captured_agents.length > 0) {
                    let agent = captured_agents.shift();
                    scene.add(agent.mesh);
                    phys.bodies.push(agent.body);
                    agents.push(agent);
                }
                //body.setPosition([24, 20, 21]);
                document.querySelector('#captured').innerHTML = '';
            }
        });

        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        function loop() {
            let delta = clock.getDelta();
            if(window.until_quiz > 0) {
                window.until_quiz -= 1;
            }
            if(jump_recovery > 0) {
                jump_recovery -= 1;
            }
            update(delta);
            render();
            requestAnimationFrame(loop);
        }

        window.render = render;
        window.world = world;
        window.updateVoxelGeometry = updateVoxelGeometry;

        loop();
    }
    
    main();
</script> 