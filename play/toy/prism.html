<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1">
<title>각기둥 전개도</title>
<style>
    body{
        margin: 0px;
        overflow: hidden;
        font-family: sans-serif;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
    }

    #stage {
        position: absolute;
        left: 0px;
        top: 0px;
        width: 100%;
        height: 100%;
    }

    #svg {
        position: absolute;
        left: 0px;
        top: 0px;
    }

    polygon {
        cursor: pointer;
    }

    polygon:hover {
        fill: rgba(255, 255, 128, 0.5);
    }

    text {
        display: none;
    }

    #ui-top {
        position: absolute;
        left: 0px;
        top: 0px;
        padding: 20px;
    }

    input, span {
        margin-right: 10px;
    }

    @media print {
        #ui-top {
            display: none;
        }

        .cross-hair {
            display: none;
        }

        .seg {
            display: none;
        }
    }
</style>
<body>
    <div id="stage"></div>
    <div id="ui-top">
        <div><input id="n-gon" type="range" min="3" max="10" value="3"><span id="desc-ngon">각형</span><button id="duplicate">복제</button></div>
        <div><input id="rot" type="range" min="0" max="360" value="0"><span id="desc-rot">회전: 0도</span></div>
        <div style="display: none;"><input id="sx" type="range" min="-10" max="10" value="-10"><span>가로 늘이기</span></div>
        <div style="display: none;"><input id="sy" type="range" min="-10" max="10" value="-10"><span>세로 늘이기</span></div>
        <hr>
        <div><input id="height" type="range" min="0" max="6" value="2"><span>기둥 높이</span></div>
        <div style="margin-top: 5px">
            <button id="pillar-conn">이어진 전개도</button>
            <button id="pillar-star">방사형 전개도</button>
        </div>
        <hr>
        <div style="margin-top: 5px">
            <button id="print">인쇄</button>
            <button id="save">저장</button>
        </div>
        <hr>
        <div><button id="clear">다시 시작</button></div>
    </div>
</body>
<script>
    const stage = document.getElementById('stage');
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    // Set the SVG attributes to make it full-screen
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);
    // Append the SVG to the container
    stage.appendChild(svg);

    let selectedMovable = null;
    let lastMovable = null;
    let lastSelectedMovable = null;
    let offsetX = 0, offsetY = 0;
    let base_size = 100;
    base_size = 173.20508075688772;

    let ngon_id_count = 0;

    // Handle window resize
    window.addEventListener('resize', () => {
        svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);
    });

    function update_movable(group) {
        if(!group) return;
        clear(group);

        let n = parseInt(document.querySelector('#n-gon').value);
        group.dataset.sx = document.querySelector('#sx').value;
        group.dataset.sy = document.querySelector('#sy').value;
        let fx = parseFloat(group.dataset.sx) / 20;
        let fy = parseFloat(group.dataset.sy) / 20;
        let [sx, sy] = [1, 1];
        if(fx < 0) {
            sx = fx/4 + 0.75;
        }
        else {
            sx = fx + 1;
        }
        if(fy < 0) {
            sy = fy/4 + 0.75;
        }
        else {
            sy = fy + 1;
        }

        if(group.dataset.type === 'ngon') {
            let cross_hair = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            cross_hair.setAttribute('d', 'M-5,0L5,0M0,-5L0,5');
            cross_hair.setAttribute('stroke', 'blue');
            cross_hair.classList.add('cross-hair');
            group.appendChild(cross_hair);    
        }

        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        group.appendChild(polygon);

        group.dataset.n = n;

        if(group.dataset['facet_ids']) {
            let facet_ids = group.dataset['facet_ids'].split(',');
            for(let i = 0; i < facet_ids.length; i++) {
                let facet_id = facet_ids[i];
                let facet = document.getElementById(facet_id);
                if(facet) {
                    facet.remove();
                }
            }
        }

        if(group.dataset['cap_id']) {
            let cap_id = group.dataset['cap_id'];
            let cap = document.getElementById(cap_id);
            if(cap) {
                cap.remove();
            }
        }

        let x0 = Math.cos(0);
        let y0 = Math.sin(0);
        let x1 = Math.cos(2 * Math.PI / n);
        let y1 = Math.sin(2 * Math.PI / n);
        let dx = x1 - x0;
        let dy = y1 - y0;
        let a = Math.PI - Math.atan2(dy, dx);
        let d = Math.sqrt(dx * dx + dy * dy);
        let r = base_size / d;
        group.dataset.r = r * sx;

        // 각 포인트에 작은 원을 생성하고 번호를 붙임
        let points = [];
        for (let i = 0; i < n; i++) {
            const theta = 2 * Math.PI * i / n + a;
            const x = Math.cos(theta) * r * sx;
            const y = Math.sin(theta) * r * sy;

            // const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            // circle.setAttribute('cx', x);
            // circle.setAttribute('cy', y);
            // circle.setAttribute('r', '5');
            // circle.setAttribute('fill', 'red');
            // group.appendChild(circle);

            // const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            // text.setAttribute('x', x);
            // text.setAttribute('y', y);
            // text.setAttribute('font-size', '20');
            // text.setAttribute('text-anchor', 'middle');
            // text.setAttribute('dominant-baseline', 'middle');
            // text.textContent = i + 1;
            // group.appendChild(text);

            points.push([x, y]);
        }
        polygon.setAttribute('points', points.map(p => p.join(',')).join(' '));
        polygon.setAttribute('fill', 'transparent');
        polygon.setAttribute('stroke', 'black');
        polygon.setAttribute('stroke-width', '1');

        if(group.dataset.rot) {
            let rot = parseFloat(group.dataset.rot);
            polygon.setAttribute('transform', `rotate(${rot})`);
        }
    }

    function add_movable(n) {
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('id', `ngon-${ngon_id_count++}`);
        group.classList.add('movable');
        svg.appendChild(group);
        group.dataset.n = n;
        let rot = parseFloat(document.querySelector('#rot').value);
        group.dataset.rot = rot;
        group.dataset.sx = parseFloat(document.querySelector('#sx').value);
        group.dataset.sy = parseFloat(document.querySelector('#sy').value);
        group.dataset.type = 'ngon';

        document.querySelector('#n-gon').value = n;
        document.querySelector('#desc-ngon').textContent = n + '각형';
        
        let last_points = '';
        if(!lastMovable) {
            group.dataset.x = window.innerWidth / 2;
            group.dataset.y = window.innerHeight / 2;
        }
        else {
            last_points = lastMovable.querySelector('polygon').getAttribute('points');
            group.dataset.x = parseFloat(lastMovable.dataset.x) + 30;
            group.dataset.y = parseFloat(lastMovable.dataset.y) + 30;
        }
        group.setAttribute('transform', `translate(${group.dataset.x}, ${group.dataset.y})`);
        
        update_movable(group);
        if(last_points) {
            group.querySelector('polygon').setAttribute('points', last_points);
        }

        lastMovable = group;
        lastSelectedMovable = group;
        lastSelectedMovable.querySelector('polygon').setAttribute('stroke-width', 2);
    }

    function clear(elem) {
        if(elem) {
            while (elem.firstChild) {
                elem.removeChild(elem.firstChild);
            }
        }
    }

    function handleStart(event) {
        let target = event.target;
        let movable = false;
        
        while(target.parentElement) {
            if(target.classList.contains('movable')) {
                movable = true;
                break;
            }
            target = target.parentElement;
        }
        
        if(movable) {
            selectedMovable = target;
            if(lastSelectedMovable) {
                lastSelectedMovable.querySelector('polygon').setAttribute('stroke-width', 1);
            }
            document.querySelector('#n-gon').value = parseInt(target.dataset.n);
            document.querySelector('#desc-ngon').textContent = target.dataset.n + '각형';
            document.querySelector('#sx').value = target.dataset.sx;
            document.querySelector('#sy').value = target.dataset.sy;
            // if(selectedMovable.dataset.type === 'ngon') {
            //     lastMovable = selectedMovable;
            //     lastSelectedMovable = lastMovable;
            //     lastSelectedMovable.querySelector('polygon').setAttribute('stroke-width', 2);
            // }
            if(target.dataset.rot) {
                let rot = parseFloat(target.dataset.rot);
                document.querySelector('#rot').value = rot;
                document.querySelector('#desc-rot').textContent = '회전: ' + Math.floor(rot) + '도';
            }

            lastMovable = selectedMovable;
            lastSelectedMovable = lastMovable;
            lastSelectedMovable.querySelector('polygon').setAttribute('stroke-width', 2);

            let rect = selectedMovable.getBoundingClientRect();

            if (event.type === 'mousedown') {
                offsetX = event.pageX - parseFloat(target.dataset.x);
                offsetY = event.pageY - parseFloat(target.dataset.y);
            } else if (event.type === 'touchstart') {
                offsetX = event.touches[0].pageX - parseFloat(target.dataset.x);
                offsetY = event.touches[0].pageY - parseFloat(target.dataset.y);    
            }
            // selectedMovable.style['-webkit-text-stroke'] = '3px blue';
            // selectedMovable.style.color = 'blue';
        }
        else {
            if(lastSelectedMovable) {
                lastSelectedMovable.querySelector('polygon').setAttribute('stroke-width', 1);
            }
            lastSelectedMovable = null;
        }
    }

    function handleMove(event) {
        if(selectedMovable) {
            let x, y;
            if (event.type === 'mousemove') {
                x = event.pageX - offsetX;
                y = event.pageY - offsetY;
            } else if (event.type === 'touchmove') {
                // event.preventDefault();
                x = event.touches[0].pageX - offsetX;
                y = event.touches[0].pageY - offsetY;
            }
            //selectedMovable.style.transform = `translate(${x}px, ${y}px)`;
            selectedMovable.setAttribute('transform', `translate(${x}, ${y})`);
            selectedMovable.dataset.x = x;
            selectedMovable.dataset.y = y;
            // selectedMovable.style['-webkit-text-stroke'] = '3px blue';
            // selectedMovable.style.color = 'blue';
            judge();
        }
        else {
            if(event.target.classList.contains('movable')) {
                // event.target.style['-webkit-text-stroke'] = '3px blue';
                // event.target.style.color = 'blue';
            }
        }
    }

    document.addEventListener('mouseout', (event) => {
        if(event.target.classList.contains('movable')) {
            // event.target.style['-webkit-text-stroke'] = '';
            // event.target.style.color = '';
        }
    });

    function handleEnd(event) {
        if(selectedMovable) {
            // selectedMovable.style['-webkit-text-stroke'] = '';
            // selectedMovable.style.color = '';
        }
        selectedMovable = null;
    }

    document.addEventListener('mousedown', handleStart);
    document.addEventListener('touchstart', handleStart);

    document.addEventListener('mousemove', handleMove);
    document.addEventListener('touchmove', handleMove);

    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchend', handleEnd);

    document.addEventListener('contextmenu', (event) => {
        event.preventDefault();
        //event.stopPropagation();
    });

    document.addEventListener('dragstart', (event) => {
        event.preventDefault();
    });

    window.addEventListener('resize', () => {
        svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);
    });

    document.querySelector('#n-gon').addEventListener('input', (event) => {
        let n = parseInt(event.target.value);
        document.querySelector('#desc-ngon').textContent = n + '각형';
        // let fx = parseFloat(document.querySelector('#sx').value) / 20;
        // let fy = parseFloat(document.querySelector('#sy').value) / 20;
        // let [sx, sy] = [1, 1];
        // if(fx < 0) {
        //     sx = fx/4 + 0.75;
        // }
        // else {
        //     sx = fx + 1;
        // }
        // if(fy < 0) {
        //     sy = fy/4 + 0.75;
        // }
        // else {
        //     sy = fy + 1;
        // }
        if(!lastMovable) {
            add_movable(n);
        }
        else {
            update_movable(lastMovable);
        }
    });

    // function update_movable(elem) {
    //     let n = parseInt(document.querySelector('#n-gon').value);
    //     let fx = parseFloat(document.querySelector('#sx').value) / 20;
    //     let fy = parseFloat(document.querySelector('#sy').value) / 20;
    //     let [sx, sy] = [1, 1];
    //     if(fx < 0) {
    //         sx = fx/4 + 0.75;
    //     }
    //     else {
    //         sx = fx + 1;
    //     }
    //     if(fy < 0) {
    //         sy = fy/4 + 0.75;
    //     }
    //     else {
    //         sy = fy + 1;
    //     }
    //     if(elem) {
    //         update_polygon(elem, n, sx, sy);
    //     }
    // }

    function build_pillar0() {
        if(!lastMovable) return;
        if(lastMovable.dataset.type !== 'ngon') return;

        lastMovable.dataset.rot = 0;
        lastMovable.querySelector('polygon').setAttribute('transform', `rotate(${lastMovable.dataset.rot})`);
        document.querySelector('#rot').value = lastMovable.dataset.rot;

        if(lastMovable.dataset['facet_ids']) {
            let facet_ids = lastMovable.dataset['facet_ids'].split(',');
            for(let i = 0; i < facet_ids.length; i++) {
                let facet_id = facet_ids[i];
                let facet = document.getElementById(facet_id);
                if(facet) {
                    facet.remove();
                }
            }
        }

        if(lastMovable.dataset['cap_id']) {
            let cap_id = lastMovable.dataset['cap_id'];
            let cap = document.getElementById(cap_id);
            if(cap) {
                cap.remove();
            }
        }

        let ngon_id = lastMovable.getAttribute('id').split('-')[1];

        let n = parseInt(lastMovable.dataset.n);
        let points = lastMovable.querySelector('polygon').getAttribute('points').trim().split(' ').map((p) => {
            let [x, y] = p.split(',');
            return [parseFloat(x), parseFloat(y)];
        });

        let cx = points[1][0] + parseFloat(lastMovable.dataset.x);
        let cy = points[1][1] + parseFloat(lastMovable.dataset.y);
        facet_ids = [];
        let ih = parseInt(document.querySelector('#height').value);
        let h = [20, 50, 100, 150, 200, 250, 300][ih];
        for(let i = 0; i < points.length; i++) {
            let p0 = points[i];
            let next = i + 1;
            if(next >= points.length) {
                next = 0;
            }
            let p1 = points[next];
            let dx = p1[0] - p0[0];
            let dy = p1[1] - p0[1];
            let d = Math.sqrt(dx * dx + dy * dy);

            let group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('transform', `translate(${cx+d/2}, ${cy+h/2})`);
            group.classList.add('movable');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            let pts = [
                [d/2, h/2],
                [-d/2, h/2],
                [-d/2, -h/2],
                [d/2, -h/2]
            ];
            polygon.setAttribute('points', pts.map(p => p.join(',')).join(' '));
            polygon.setAttribute('fill', 'transparent');
            polygon.setAttribute('stroke', 'black');
            polygon.setAttribute('stroke-width', '1');

            group.dataset.type = 'facet';
            group.dataset.n = pts.length;
            group.dataset.r = Math.sqrt(d * d + h * h)/2;
            group.dataset.x = cx+d/2;
            group.dataset.y = cy+h/2;
            group.dataset.sx = -10
            group.dataset.sy = -10;
            group.dataset.rot = 0;
            let facet_id = `facet-${ngon_id}-${i}`;
            group.setAttribute('id', facet_id);
            facet_ids.push(facet_id);
            group.appendChild(polygon);
            svg.appendChild(group);
            cx += d;
        }
        lastMovable.dataset.facet_ids = facet_ids.join(',');

        // cap
        let group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('id', `cap-${ngon_id}`);
        group.dataset.type = 'cap';
        group.dataset.n = n;
        group.dataset.r = lastMovable.dataset.r;
        group.dataset.x = lastMovable.dataset.x;
        group.dataset.y = cy + h + points[0][1];
        group.dataset.rot = 0;
        group.setAttribute('transform', `translate(${group.dataset.x}, ${group.dataset.y })`);
        group.classList.add('movable');
        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        let pts = points.map(p => [p[0], -p[1]]);
        polygon.setAttribute('points', pts.map(p => p.join(',')).join(' '));
        polygon.setAttribute('fill', 'transparent');
        polygon.setAttribute('stroke', 'black');
        polygon.setAttribute('stroke-width', '1');
        lastMovable.dataset.cap_id = group.getAttribute('id');
        group.appendChild(polygon);
        svg.appendChild(group);
    }

    function build_pillar() {
        if(!lastMovable) return;
        if(lastMovable.dataset.type !== 'ngon') return;

        lastMovable.dataset.rot = 0;
        lastMovable.querySelector('polygon').setAttribute('transform', `rotate(${lastMovable.dataset.rot})`);
        document.querySelector('#rot').value = lastMovable.dataset.rot;

        if(lastMovable.dataset['facet_ids']) {
            let facet_ids = lastMovable.dataset['facet_ids'].split(',');
            for(let i = 0; i < facet_ids.length; i++) {
                let facet_id = facet_ids[i];
                let facet = document.getElementById(facet_id);
                if(facet) {
                    facet.remove();
                }
            }
        }

        if(lastMovable.dataset['cap_id']) {
            let cap_id = lastMovable.dataset['cap_id'];
            let cap = document.getElementById(cap_id);
            if(cap) {
                cap.remove();
            }
        }

        let ngon_id = lastMovable.getAttribute('id').split('-')[1];

        let n = parseInt(lastMovable.dataset.n);
        let points = lastMovable.querySelector('polygon').getAttribute('points').trim().split(' ').map((p) => {
            let [x, y] = p.split(',');
            return [parseFloat(x), parseFloat(y)];
        });

        // let cx = points[1][0] + parseFloat(lastMovable.dataset.x);
        // let cy = points[1][1] + parseFloat(lastMovable.dataset.y);
        let cx = parseFloat(lastMovable.dataset.x);
        let cy = parseFloat(lastMovable.dataset.y);
        facet_ids = [];
        let ih = parseInt(document.querySelector('#height').value);
        let h = [20, 50, 100, 150, 200, 250, 300][ih];
        for(let i = 0; i < points.length; i++) {
            let p0 = points[i];
            let next = i + 1;
            if(next >= points.length) {
                next = 0;
            }
            let p1 = points[next];
            let dx = p1[0] - p0[0];
            let dy = p1[1] - p0[1];
            let d = Math.sqrt(dx * dx + dy * dy);

            let group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.classList.add('movable');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            let pts = [
                [d/2, h/2],
                [-d/2, h/2],
                [-d/2, -h/2],
                [d/2, -h/2]
            ];
            let theta = Math.atan2(dy, dx);
            let angle = 180 - theta / Math.PI * 180;

            polygon.setAttribute('points', pts.map(p => p.join(',')).join(' '));
            polygon.setAttribute('transform', `rotate(${angle})`);
            polygon.setAttribute('fill', 'transparent');
            polygon.setAttribute('stroke', 'black');
            polygon.setAttribute('stroke-width', '1');

            group.dataset.type = 'facet';
            group.dataset.n = pts.length;
            group.dataset.r = Math.sqrt(d * d + h * h)/2;
            group.dataset.x = cx - (h/2 + points[0][1]) * Math.sin(theta);
            group.dataset.y = cy - (h/2 + points[0][1]) * Math.cos(theta);
            group.dataset.sx = -10
            group.dataset.sy = -10;
            group.dataset.rot = angle;
            group.setAttribute('transform', `translate(${group.dataset.x}, ${group.dataset.y})`);

            let facet_id = `facet-${ngon_id}-${i}`;
            group.setAttribute('id', facet_id);
            facet_ids.push(facet_id);
            group.appendChild(polygon);
            svg.appendChild(group);
        }
        lastMovable.dataset.facet_ids = facet_ids.join(',');

        // cap
        let group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('id', `cap-${ngon_id}`);
        group.dataset.type = 'cap';
        group.dataset.n = n;
        group.dataset.r = lastMovable.dataset.r;
        group.dataset.x = lastMovable.dataset.x
        group.dataset.y = cy + h + 2 * points[0][1];
        group.dataset.rot = 0;
        group.setAttribute('transform', `translate(${group.dataset.x}, ${group.dataset.y })`);
        group.classList.add('movable');
        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        let pts = points.map(p => [p[0], -p[1]]);
        polygon.setAttribute('points', pts.map(p => p.join(',')).join(' '));
        polygon.setAttribute('fill', 'transparent');
        polygon.setAttribute('stroke', 'black');
        polygon.setAttribute('stroke-width', '1');
        lastMovable.dataset.cap_id = group.getAttribute('id');
        group.appendChild(polygon);
        svg.appendChild(group);
    }

    document.querySelector('#sx').addEventListener('input', (event) => {
        if(lastMovable) {
            update_movable(lastMovable);
        }
    });

    document.querySelector('#sy').addEventListener('input', (event) => {
        if(lastMovable) {
            update_movable(lastMovable);
        }
    });

    document.querySelector('#rot').addEventListener('input', (event) => {
        if(lastMovable) {
            let rot = parseFloat(event.target.value);
            document.querySelector('#desc-rot').textContent = '회전: ' + Math.floor(rot) + '도';
            let polygon = lastMovable.querySelector('polygon');
            polygon.setAttribute('transform', `rotate(${rot})`);
            lastMovable.dataset.rot = rot;
        }
    });

    document.querySelector('#height').addEventListener('input', (event) => {
        if(lastMovable) {
            build_pillar();

            if(lastMovable.dataset['facet_ids']) {
                let facet_ids = lastMovable.dataset['facet_ids'].split(',');
                for(let i = 1; i < facet_ids.length; i++) {
                    let facet_id = facet_ids[i];
                    let facet = document.getElementById(facet_id);
                    if(facet) {
                        facet.remove();
                    }
                }
            }

            if(lastMovable.dataset['cap_id']) {
                let cap_id = lastMovable.dataset['cap_id'];
                let cap = document.getElementById(cap_id);
                if(cap) {
                    cap.remove();
                }
            }
        }
    });

    document.querySelector('#pillar-conn').addEventListener('click', (event) => {
        build_pillar0();
    });

    document.querySelector('#pillar-star').addEventListener('click', (event) => {
        build_pillar();
    });

    document.querySelector('#duplicate').addEventListener('click', (event) => {
        add_movable(parseInt(document.querySelector('#n-gon').value));
    });

    document.querySelector('#print').addEventListener('click', (event) => {
        lastMovable = null;
        lastSelectedMovable = null;
        selectedMovable = null;

        let temp_svg_inner_string = svg.innerHTML;
        let temp_width = svg.getAttribute('width');
        let temp_height = svg.getAttribute('height');
        let temp_viewBox = svg.getAttribute('viewBox');
        let svg_print = svg.cloneNode(true);

        let left = Number.MAX_VALUE;
        let top = Number.MAX_VALUE;
        let right = Number.MIN_VALUE;
        let bottom = Number.MIN_VALUE;

        let polygons = svg.querySelectorAll('polygon');
        for(let p of polygons) {
            let rect = p.getBoundingClientRect();
            if(rect.left < left) left = rect.left;
            if(rect.top < top) top = rect.top;
            if(rect.right > right) right = rect.right;
            if(rect.bottom > bottom) bottom = rect.bottom;
        }

        svg_print.innerHTML = '';
        let g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.innerHTML = temp_svg_inner_string;
        let scale = 1.5;
        // svg_print.setAttribute('width', (right - left));
        // svg_print.setAttribute('height', (bottom - top));
        // svg_print.setAttribute('viewBox', `${0} ${0} ${right - left} ${bottom - top}`);
        g.setAttribute('transform', `scale(${scale}, ${scale}) translate(${-left}, ${-top})`);
        svg_print.appendChild(g);
        let w = 210 * 4;
        let h = 297 * 4;
        svg.setAttribute('width', w);
        svg.setAttribute('height', h);
        svg.setAttribute('viewBox', `${0} ${0} ${w} ${h}`);
        svg.innerHTML = svg_print.innerHTML;
        
        window.print();
        svg_print.remove();
        svg.setAttribute('width', temp_width);
        svg.setAttribute('height', temp_height);
        svg.setAttribute('viewBox', temp_viewBox);
        svg.innerHTML = temp_svg_inner_string;
    });

    document.querySelector('#clear').addEventListener('click', (event) => {
        clear(svg);
        lastMovable = null;
        lastSelectedMovable = null;
        add_movable(parseInt(document.querySelector('#n-gon').value));
    });

    document.addEventListener('keyup', (event) => {
        //  스페이스 눌렀을 때 선택된 movable 복제
        if(event.keyCode === 32) {
            if(lastMovable) {
                let n = parseInt(lastMovable.dataset.n);
                add_movable(n);
            }
        }

        // 백스페이스 눌렀을 때 선택된 movable 지우기
        if(event.keyCode === 8) {
            if(lastMovable) {
                lastMovable.remove();
                lastMovable = null;
            }
        }
    });

    // 키보드 화살표 상하를 눌렀을 때 n각형 조정 min, max 넘지 않게. ui도 업데이트
    document.addEventListener('keydown', (event) => {
        if(event.keyCode === 38) {
            if(lastMovable) {
                let n = parseInt(lastMovable.dataset.n);
                if(n < 10) {
                    n++;
                    document.querySelector('#n-gon').value = n;
                    document.querySelector('#desc-ngon').textContent = n + '각형';
                    update_movable(lastMovable);
                }
            }
        }
        else if(event.keyCode === 40) {
            if(lastMovable) {
                let n = parseInt(lastMovable.dataset.n);
                if(n > 3) {
                    n--;
                    document.querySelector('#n-gon').value = n;
                    document.querySelector('#desc-ngon').textContent = n + '각형';
                    update_movable(lastMovable);
                }
            }
        }
    });

    // 키보드 화살표 좌우를 눌렀을 때 회전 조정, 0보다 작으면 0까지. 360보다 크면 360까지. 그 360 / n 도씩 돌아가게. ui도 업데이트
    document.addEventListener('keydown', (event) => {
        if(event.keyCode === 37) {
            if(lastMovable) {
                let rot = parseFloat(lastMovable.dataset.rot);
                rot -= 360 / parseInt(lastMovable.dataset.n) / 8;
                if(rot < 0) {
                    rot = 0;
                }
                document.querySelector('#rot').value = rot;
                document.querySelector('#desc-rot').textContent = '회전: ' + Math.floor(rot) + '도';
                lastMovable.querySelector('polygon').setAttribute('transform', `rotate(${rot})`);
                lastMovable.dataset.rot = rot;
            }
        }
        else if(event.keyCode === 39) {
            if(lastMovable) {
                let rot = parseFloat(lastMovable.dataset.rot);
                rot += 360 / parseInt(lastMovable.dataset.n) / 8;
                if(rot > 360) {
                    rot = 360;
                }
                document.querySelector('#rot').value = rot;
                document.querySelector('#desc-rot').textContent = '회전: ' + Math.floor(rot) + '도';
                lastMovable.querySelector('polygon').setAttribute('transform', `rotate(${rot})`);
                lastMovable.dataset.rot = rot;
            }
        }
    });

    document.querySelector('#save').addEventListener('click', (event) => {
        // save 버튼을 누르면 svg를 xml형식으로 변환하여 파일로 다운로드
        let svg = document.querySelector('svg');
        let svg_xml = new XMLSerializer().serializeToString(svg);
        let blob = new Blob([svg_xml], {type: 'image/svg+xml'});
        let url = URL.createObjectURL(blob);
        let a = document.createElement('a');
        a.href = url;
        a.download = 'pillar.svg';
        a.click();
    });
    
    add_movable(3);

    //----------------------------
    // SVG polygon 객체에서 points와 transform을 추출하여 배열로 변환
function getTransformedPointsFromPolygon(polygon) {
  const pointsAttr = polygon.getAttribute("points");
  const pointTuples = pointsAttr.trim().split(/\s+/).map(pt => pt.split(",").map(Number));

  const transformAttr = polygon.parentElement.getAttribute("transform");
  const translateMatch = transformAttr.match(/translate\(([^,]+),\s*([^)]+)\)/);

  if (translateMatch) {
    const tx = parseFloat(translateMatch[1]);
    const ty = parseFloat(translateMatch[2]);

    // Apply the translation to each point
    return pointTuples.map(pt => [pt[0] + tx, pt[1] + ty]);
  }
  
  return pointTuples;
}

// 두 점 사이의 거리를 계산하는 함수
function getDistance(p1, p2) {
  return Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2);
}

// 벡터 덧셈
function addVec(a, b) {
  return [a[0] + b[0], a[1] + b[1]];
}

// 벡터 뺄셈
function subVec(a, b) {
  return [a[0] - b[0], a[1] - b[1]];
}

// 스칼라곱
function dotVec(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

// 벡터의 크기를 계산
function magnitudeVec(a) {
  return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
}

// 선분과 점 사이의 거리를 계산
function pointToLineDistance(A, B, C) {
  const numerator = Math.abs((B[0] - A[0]) * (A[1] - C[1]) - (A[0] - C[0]) * (B[1] - A[1]));
  const denominator = magnitudeVec([B[0] - A[0], B[1] - A[1]]);
  return numerator / denominator;
}

// 스칼라 투영
function scalarProjection(A, B, C) {
  const BA = [A[0] - B[0], A[1] - B[1]];
  const BC = [C[0] - B[0], C[1] - B[1]];
  return dotVec(BA, BC) / magnitudeVec(BA);
}

// 선분 a와 b 사이의 최단 거리를 계산
function getMinDistSegment(a, b) {
  const [p0, p1] = a;
  const [q0, q1] = b;

  let minDist = Infinity;

  // a의 각 끝점에서 b로 수선을 떨어뜨림
  for (const point of [p0, p1]) {
    const t = scalarProjection(q0, q1, point);
    if (t >= 0 && t <= magnitudeVec([q1[0] - q0[0], q1[1] - q0[1]])) {
      const dist = pointToLineDistance(q0, q1, point);
      minDist = Math.min(minDist, dist);
    }
  }

  // b의 각 끝점에서 a로 수선을 떨어뜨림
  for (const point of [q0, q1]) {
    const t = scalarProjection(p0, p1, point);
    if (t >= 0 && t <= magnitudeVec([p1[0] - p0[0], p1[1] - p0[1]])) {
      const dist = pointToLineDistance(p0, p1, point);
      minDist = Math.min(minDist, dist);
    }
  }

  return minDist;
}


// 두 다각형 객체 사이의 최단 거리 및 해당하는 선분 쌍을 찾는 함수
function getMinDistPolygon(polygonA, polygonB) {
  const a = getTransformedPointsFromPolygon(polygonA);
  const b = getTransformedPointsFromPolygon(polygonB);

  let minDist = Infinity;
  let closestPair = [];
  let closestPairIndex = [-1, -1];  // [a의 선분 인덱스, b의 선분 인덱스]

  for (let i = 0; i < a.length; i++) {
    const aSegment = [a[i], a[(i + 1) % a.length]];
    for (let j = 0; j < b.length; j++) {
      const bSegment = [b[j], b[(j + 1) % b.length]];
      const dist = getMinDistSegment(aSegment, bSegment);
      if (dist < minDist) {
        minDist = dist;
        closestPair = [aSegment, bSegment];
        closestPairIndex = [i, j];
      }
    }
  }
  
  return { minDist, closestPair, closestPairIndex };
}

// 예제 사용법 (HTML 문서에 SVG polygon 객체가 있어야 함)
// const polygonA = document.getElementById("polygonA");
// const polygonB = document.getElementById("polygonB");
// const result = getMinDistPolygon(polygonA, polygonB);
// console.log("최단 거리:", result.minDist);
// console.log("해당하는 선분 쌍:", result.closestPair);
// console.log("해당하는 선분 인덱스:", result.closestPairIndex);
//

    function test(pair) {
        let count = 0;
        for(let l of pair) {
            for(let p of l) {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', p[0]);
                    circle.setAttribute('cy', p[1]);
                    circle.setAttribute('r', '3');
                    circle.setAttribute('fill', count == 0 ? 'red' : 'blue');
                    svg.appendChild(circle);
            }
            count++;
        }
    }

    function judge() {
        Array.from(document.querySelectorAll('.seg')).forEach(
            p => p.remove()
        );

        if(selectedMovable) {
            let movables = document.querySelectorAll('.movable');
            let cx = parseFloat(selectedMovable.dataset.x);
            let cy = parseFloat(selectedMovable.dataset.y);
            let t0 = parseFloat(selectedMovable.dataset.rot) / 180 * Math.PI;
            let pas = selectedMovable.querySelector('polygon').getAttribute('points').split(' ').map((p) => {
                let [x, y] = p.split(',');
                // 회전한 결과 좌표
                return [cx + parseFloat(x) * Math.cos(t0) - parseFloat(y) * Math.sin(t0), cy + parseFloat(x) * Math.sin(t0) + parseFloat(y) * Math.cos(t0)];
                //return [cx + parseFloat(x), cy + parseFloat(y)];
            });
            for(let movable of movables) {
                if(movable === selectedMovable) continue;
                let tx = parseFloat(movable.dataset.x);
                let ty = parseFloat(movable.dataset.y);
                let dx = cx - tx;
                let dy = cy - ty
                let d = Math.sqrt(dx * dx + dy * dy);
                let r0 = parseFloat(selectedMovable.dataset.r);
                let r1 = parseFloat(movable.dataset.r);
                if(d < r0 + r1) {
                    let t1 = parseFloat(movable.dataset.rot) / 180 * Math.PI;
                    let pbs = movable.querySelector('polygon').getAttribute('points').split(' ').map((p) => {
                        let [x, y] = p.split(',');
                        // 회전한 결과 좌표
                        return [tx + parseFloat(x) * Math.cos(t1) - parseFloat(y) * Math.sin(t1), ty + parseFloat(x) * Math.sin(t1) + parseFloat(y) * Math.cos(t1)];
                        // return [tx + parseFloat(x), ty + parseFloat(y)];
                    });
                    for(let i = 0; i < pas.length; i++) {
                        let p0 = pas[i];
                        let next = i + 1;
                        if(next >= pas.length) {
                            next = 0;
                        }
                        let p1 = pas[next];
                        let ca = [(p0[0] + p1[0])/2, (p0[1] + p1[1])/2];

                        for(let j = 0; j < pbs.length; j++) {
                            let p2 = pbs[j];
                            let next = j + 1;
                            if(next >= pbs.length) {
                                next = 0;
                            }
                            let p3 = pbs[next];
                            let cb = [(p2[0] + p3[0])/2, (p2[1] + p3[1])/2];
                            let dx = ca[0] - cb[0];
                            let dy = ca[1] - cb[1];
                            let d = Math.sqrt(dx * dx + dy * dy);
                            if(d < 30) {
                                let seg = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                seg.setAttribute('x1', p0[0]);
                                seg.setAttribute('y1', p0[1]);
                                seg.setAttribute('x2', p1[0]);
                                seg.setAttribute('y2', p1[1]);
                                seg.setAttribute('stroke', 'red');
                                seg.setAttribute('stroke-width', '2');
                                seg.classList.add('seg');
                                svg.appendChild(seg);
                                seg = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                seg.setAttribute('x1', p2[0]);
                                seg.setAttribute('y1', p2[1]);
                                seg.setAttribute('x2', p3[0]);
                                seg.setAttribute('y2', p3[1]);
                                seg.setAttribute('stroke', 'red');
                                seg.setAttribute('stroke-width', '2');
                                seg.classList.add('seg');
                                svg.appendChild(seg);
                                
                                let tt = Math.atan2(p3[1] - p2[1], p3[0] - p2[0]) * 180 / Math.PI;
                                if(tt < 0) {
                                    tt += 360;
                                }
                                selectedMovable.dataset.rot = tt;
                                selectedMovable.querySelector('polygon').setAttribute('transform', `rotate(${selectedMovable.dataset.rot})`);
                                document.querySelector('#rot').value = selectedMovable.dataset.rot;
                                document.querySelector('#desc-rot').textContent = '회전: ' + Math.floor(selectedMovable.dataset.rot) + '도';

                                return;
                            }
                        }
                        
                    }
                }
            }
        }
    }
</script>