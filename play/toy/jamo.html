<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1">
<title>한글 자모</title>
<style>
    body{
        margin: 0px;
        overflow: hidden;
        font-family: sans-serif;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
    }

    #stage {
        position: absolute;
        left: 0px;
        top: 0px;
        width: 100%;
        height: 100%;
    }

    #svg {
        position: absolute;
        left: 0px;
        top: 0px;
    }

    .scalerot {
        transition: 0.2s;
    }

    .glyph {
        cursor: move;
    }

    .touch-aid {
        cursor: move;
    }

    #ui-top {
        position: absolute;
        left: 0px;
        top: 0px;
        width: 100%;
        padding: 30px;
        box-sizing: border-box;
        border-bottom: 1px solid black;
    }

    /* #ui-bottom {
        position: absolute;
        left: 0px;
        bottom: 0px;
        width: 100%;
        height: 100px;
        padding: 30px;
        box-sizing: border-box;
        border-top: 1px solid black;
    } */

    .jamo-button {
        display: inline-block;
        margin: 5px;
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
        background-size: contain;
        transform-origin: center center;
        transition: transform 0.2s;
    }

    .jamo-button:hover {
        transform: scale(1.25);
    }

    #logotype {
        position: absolute;
        left: 20px;
        bottom: 20px;
        height: 20px;
        opacity: 0.5;
    }
</style>
<body>
    <img id="logotype" src="https://www.hanmiu.cc/images/logotype/hanmi_logotype.svg">
    <div id="stage">
        <!-- <svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="m -25,-25 50,0 M 0,0 25,25 M 0,-25 0,0 -25,25" stroke="black" stroke-width="5" stroke-linecap="round" stroke-linejoin="round" fill="none" transform="translate(50, 50)"></svg> -->
    </div>
    <div id="ui-top"></div>
    <!-- <div id="ui-bottom"></div> -->
</body>
<script>
    const stage = document.getElementById('stage');
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
    svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);
    stage.appendChild(svg);

    let jamoset = {
        'ᄀ': 'm -25,-25 50,0 0,50',
        'ᄂ': 'm -25,-25 0,50 50,0',
        'ᄃ': 'm 25,-25 -50,0 0,50 50,0',
        'ᄅ': 'm -25,-25 50,0 0,25 -50,0 0,25 50,0',
        'ᄆ': 'm -25,-25 50,0 0,50 -50,0 z',
        'ᄇ': 'm -25,0 50,0 m -50,-25 0,50 50,0 0,-50',
        'ᄉ': 'M 0,0 25,25 M 0,-25 0,0 -25,25',
        'ᄋ': 'M 25,0 A 25,25 0 1 1 -25,0 25,25 0 1 1 25,0 z',
        'ᄌ': 'm -25,-25 50,0 M 0,0 25,25 M 0,-25 0,0 -25,25',
        'ᄎ': 'm 0,-40 0,10 m -25,5 50,0 M 0,0 25,25 M 0,-25 0,0 -25,25',
        'ᄏ': 'm -25,0 50,0 m -50,-25 50,0 0,50',
        'ᄐ': 'm -25,0 50,0 m 0,-25 -50,0 0,50 50,0',
        'ᄑ': 'm 15,-25 0,50 m -30,-50 0,50 m -10,0 50,0 m -50,-50 50,0',
        'ᄒ': 'm 20,5 c 0,11 -9,20 -20,20 -11,0 -20,-9 -20,-20 0,-11 9,-20 20,-20 11,0 20,9 20,20 z M 0,-40 0,-30 m -25,5 50,0',
        'ᅡ': 'M 0,0 20,0 M 0,-40 0,40',	
        'ᅣ': 'm 0,15 20,0 M 0,-15 20,-15 M 0,-40 0,40',
        'ᅥ': 'M -20,0 0,0 m 0,-40 0,80',
        'ᅧ': 'm -20,15 20,0 m -20,-30 20,0 m 0,-25 0,80',
        'ᅩ': 'M 0,-20 0,0 m -40,0 80,0',
        'ᅭ': 'm 15,-20 0,20 m -30,-20 0,20 m -25,0 80,0',
        'ᅮ': 'M 0,0 0,20 M -40,0 40,0',
        'ᅲ': 'm 15,0 0,20 M -15,0 -15,20 M -40,0 40,0',
        'ᅳ': 'M -40,0 40,0',
        'ᅵ': 'M 0,-40 0,40' 
    };

    let selectedMovable = null;
    let lastMovable = null;
    let [offsetX, offsetY] = [0, 0];
    let action_history = [];
    let action_history_buffer = [];
    let last_acted_time = 0;
    let base_stroke_width = 10;
    let selected_stroke_color = 'blue';
    let selected_stroke_width = 4;

    function init() {
        // top-ui 자모 선택
        for (let jamo in jamoset) {        
            let svg_string = `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="${jamoset[jamo]}" stroke="black" stroke-width="${base_stroke_width}" stroke-linecap="round" stroke-linejoin="round" fill="none" transform="translate(50, 50)"></path></svg>`;

            const encoded_svg = encodeURIComponent(svg_string);
            const el = document.createElement('div');
            el.classList.add('jamo-button');
            el.style['background-image'] = `url("data:image/svg+xml,${encoded_svg}")`;
            let size = Math.max(window.innerWidth, window.innerHeight) / 25;
            el.style['width']= `${size}px`;
            el.style['height'] = `${size}px`;
            el.dataset.jamo = jamo;
            document.querySelector('#ui-top').appendChild(el);
        }
    }

    function resize() {
        let jamo_size = Math.max(window.innerWidth, window.innerHeight) / 25;
        svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);
        for(let jb of document.querySelectorAll('.jamo-button')) {
            jb.style['width']= `${jamo_size}px`;
            jb.style['height'] = `${jamo_size}px`;
        }

        // document.querySelector('#ui-bottom').style['height'] = `${jamo_size * 3}px`;
    }

    function add_movable(jamo) {
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.classList.add('movable');
        svg.appendChild(group);

        const scalerot = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        scalerot.classList.add('scalerot');
        group.appendChild(scalerot);

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.classList.add('touch-aid');
        circle.setAttribute('cx', '0');
        circle.setAttribute('cy', '0');
        circle.setAttribute('r', '25');
        circle.setAttribute('stroke', 'none');
        circle.setAttribute('fill', 'transparent');
        scalerot.appendChild(circle);

        let stroke_width = base_stroke_width;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.classList.add('glyph');
        path.setAttribute('d', jamoset[jamo]);
        path.setAttribute('stroke', 'black');
        path.setAttribute('stroke-width', stroke_width);
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        path.setAttribute('fill', 'none');

        let halo = path.cloneNode();
        halo.classList.remove('glyph');
        halo.classList.add('halo');
        halo.setAttribute('stroke', 'transparent');
        halo.setAttribute('stroke-width', stroke_width + 1);
        scalerot.appendChild(halo);
        scalerot.appendChild(path);

        group.dataset.jamo = jamo;
        group.dataset.rot = 0;
        group.dataset.scale = 1;
        group.dataset.type = 'jamo';

        return group;
    }

    function handleStart(event) {
        let target = event.target;
        let movable = false;

        if(target.classList.contains('jamo-button')) {
            movable = true;
            let group = add_movable(target.dataset.jamo);
            group.dataset.x = event.pageX;
            group.dataset.y = event.pageY;
            group.setAttribute('transform', `translate(${event.pageX}, ${event.pageY})`);
            target = group;
        }

        document.querySelectorAll('.halo').forEach((el) => {
            el.setAttribute('stroke', 'transparent');
        });
        
        while(target.parentElement) {
            if(target.classList.contains('movable')) {
                movable = true;
                break;
            }
            target = target.parentElement;
        }
        
        if(movable) {
            selectedMovable = target;
            lastMovable = selectedMovable;
            let scale = parseFloat(selectedMovable.dataset.scale);
            let stroke_width = base_stroke_width / scale;
            selectedMovable.querySelector('.halo').setAttribute('stroke-width', stroke_width + selected_stroke_width / scale);
            selectedMovable.querySelector('.halo').setAttribute('stroke', selected_stroke_color);
            selectedMovable.querySelector('.halo').setAttribute('stroke-opacity', 0.5);

            if (event.type === 'mousedown') {
                offsetX = event.pageX - parseFloat(target.dataset.x);
                offsetY = event.pageY - parseFloat(target.dataset.y);
            } else if (event.type === 'touchstart') {
                offsetX = event.touches[0].pageX - parseFloat(target.dataset.x);
                offsetY = event.touches[0].pageY - parseFloat(target.dataset.y);    
            }
        }
        else {
            //---
        }
    }

    function handleMove(event) {
        if(selectedMovable) {
            let x, y;
            if (event.type === 'mousemove') {
                x = event.pageX - offsetX;
                y = event.pageY - offsetY;
            } else if (event.type === 'touchmove') {
                // event.preventDefault();
                x = event.touches[0].pageX - offsetX;
                y = event.touches[0].pageY - offsetY;
            }
            selectedMovable.setAttribute('transform', `translate(${x}, ${y})`);
            selectedMovable.dataset.x = x;
            selectedMovable.dataset.y = y;
        }
        else {
            if(event.target.classList.contains('movable')) {
                // event.target.style['-webkit-text-stroke'] = '3px blue';
                // event.target.style.color = 'blue';
            }
        }
    }

    document.addEventListener('mouseout', (event) => {
        if(event.target.classList.contains('movable')) {
            // event.target.style['-webkit-text-stroke'] = '';
            // event.target.style.color = '';
        }
    });

    function handleEnd(event) {
        if(selectedMovable) {
            let ui_top_rect = document.querySelector('#ui-top').getBoundingClientRect();
            if(selectedMovable.dataset.y < ui_top_rect.bottom) {
                if(lastMovable === selectedMovable) {
                    lastMovable = null;
                }
                selectedMovable.remove();
            }

            // let ui_bottom_rect = document.querySelector('#ui-bottom').getBoundingClientRect();
            // if(selectedMovable.dataset.y > ui_bottom_rect.top) {
            //     if(lastMovable === selectedMovable) {
            //         lastMovable = null;
            //     }
            //     selectedMovable.remove();
            // }
            action();
        }
        selectedMovable = null;
    }

    document.addEventListener('mousedown', handleStart);
    document.addEventListener('touchstart', handleStart);

    document.addEventListener('mousemove', handleMove);
    document.addEventListener('touchmove', handleMove);

    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchend', handleEnd);

    document.addEventListener('contextmenu', (event) => {
        event.preventDefault();
        //event.stopPropagation();
    });

    window.addEventListener('resize', () => {
        resize();
    });

    window.addEventListener("orientationchange", (event) => {
        setTimeout(() => {
            resize();
        }, 100);
    });

    document.addEventListener('keyup', (event) => {
        if(lastMovable) {
            let scale = parseFloat(lastMovable.dataset.scale);
            let rot = parseFloat(lastMovable.dataset.rot);
            let stroke_width = base_stroke_width / scale;
            let acted = false;

            // 스페이스 눌렀을 때 선택된 movable 복제
            if(event.keyCode === 32) {
                lastMovable.querySelector('.halo').setAttribute('stroke', 'transparent');
                let group = add_movable(lastMovable.dataset.jamo);
                let scalerot = group.querySelector('.scalerot');
                let halo = group.querySelector('.halo');
                let glyph = group.querySelector('.glyph');
                group.dataset.x = parseFloat(lastMovable.dataset.x) + 30;
                group.dataset.y = parseFloat(lastMovable.dataset.y) + 30;
                group.dataset.scale = scale;
                group.dataset.rot = rot;
                group.setAttribute('transform', `translate(${group.dataset.x}, ${group.dataset.y})`);
                scalerot.setAttribute('transform', `rotate(${group.dataset.rot}) scale(${group.dataset.scale})`);
                glyph.setAttribute('stroke-width', stroke_width);
                halo.setAttribute('stroke-width', stroke_width + selected_stroke_width / scale);
                halo.setAttribute('stroke', selected_stroke_color);
                halo.setAttribute('stroke-opacity', 0.5);
                lastMovable = group;
                acted = true;
            }

            // 백스페이스 눌렀을 때 선택된 movable 지우기
            if(event.keyCode === 8) {
                lastMovable.remove();
                lastMovable = null;
                acted = true;
            }

            if(acted) {
                action();
            }
        }
    });

    // 키보드 화살표 상하를 눌렀을 때 scale 조절
    document.addEventListener('keydown', (event) => {
        if(lastMovable) {
            let scale = parseFloat(lastMovable.dataset.scale);
            let rot = parseFloat(lastMovable.dataset.rot);
            let scalerot = lastMovable.querySelector('.scalerot');
            let halo = lastMovable.querySelector('.halo');
            let glyph = lastMovable.querySelector('.glyph');
            let stroke_width = base_stroke_width / scale;
            let acted = false;

            if(event.keyCode === 38) {
                scale += 0.1;
                if(scale > 2) scale = 2;
                acted = true;
            }
            else if(event.keyCode === 40) {
                scale -= 0.1;
                if(scale < 0.5) scale = 0.5;   
                acted = true;
            }
            else if(event.keyCode === 37) { // 키보드 화살표 좌우를 눌렀을 때 rot 조절
                rot -= 5;
                acted = true;
            }
            else if(event.keyCode === 39) {
                rot += 5;
                acted = true;
            }

            if(acted) {
                lastMovable.dataset.scale = scale;
                lastMovable.dataset.rot = rot;
                scalerot.setAttribute('transform', `rotate(${lastMovable.dataset.rot}) scale(${lastMovable.dataset.scale})`);
                halo.setAttribute('stroke-width', stroke_width + selected_stroke_width / scale);
                halo.setAttribute('stroke-opacity', 0.5);
                glyph.setAttribute('stroke-width', stroke_width);
                action();
            }
        }
    });

    function action() {
        let acted_time = performance.now();
        let elapsed_time = acted_time - last_acted_time;
        last_acted_time = acted_time;
        if(elapsed_time < 500) {
            action_history.pop();
        }
        action_history.push(svg.innerHTML);
        while(action_history_buffer.length > 0) {
            action_history_buffer.pop();
        }
    }

    function undo() {
        if(action_history.length > 0) {
            const popped = action_history.pop();
            action_history_buffer.push(popped);
            svg.innerHTML = action_history[action_history.length - 1];
            document.querySelectorAll('.halo').forEach((el) => {
                el.setAttribute('stroke', 'transparent');
            });
            lastMovable = null;
        }
    }

    function redo() {
        if(action_history_buffer.length > 0) {
            const popped = action_history_buffer.pop();
            action_history.push(popped);
            svg.innerHTML = action_history[action_history.length - 1];
            document.querySelectorAll('.halo').forEach((el) => {
                el.setAttribute('stroke', 'transparent');
            });
            lastMovable = null;
        }
    }

    function formatDateToString(date) {
        // 년, 월, 일, 시, 분, 초를 추출합니다.
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');  // 월은 0-based, 따라서 +1을 해줍니다.
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');

        // 파일명 포맷에 맞게 결합합니다.
        return `${year}${month}${day}_${hours}${minutes}${seconds}`;
    }

    function save_svg() {
        // save 버튼을 누르면 svg를 xml형식으로 변환하여 파일로 다운로드
        el_svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        el_svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        el_svg.setAttribute('width', '100%');
        el_svg.setAttribute('height', '100%');
        el_svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);

        el_svg.innerHTML = svg.innerHTML;
        
        for(let el of el_svg.querySelectorAll('.touch-aid')) {
            el.remove();
        }

        for(let el of el_svg.querySelectorAll('.halo')) {
            el.remove();
        }
  
        let svg_xml = new XMLSerializer().serializeToString(el_svg);
        let blob = new Blob([svg_xml], {type: 'image/svg+xml'});
        let url = URL.createObjectURL(blob);
        let a = document.createElement('a');
        a.href = url;
        a.download = `jamo_${formatDateToString(new Date())}.svg`;
        a.click();
    }

    // Listen for the dragover event
    svg.addEventListener('dragover', function (event) {
        event.preventDefault();
    });

    // Listen for the drop event, loading SVG
    svg.addEventListener('drop', function (event) {
        event.preventDefault();

        // Get the files that were dragged
        const files = event.dataTransfer.files;

        // Process each file
        for (const file of files) {
            // Only work with SVG files
            if (file.type === 'image/svg+xml') {
                // Create a FileReader to read the file
                const reader = new FileReader();
                
                reader.onload = function (e) {
                    // Log the SVG string to the console
                    let div = document.createElement('div');
                    div.innerHTML = e.target.result;
                    let el_svg = div.querySelector('svg');
                    for(let group of el_svg.querySelectorAll('.movable')) {
                        const scalerot = group.querySelector('.scalerot');
                        const glyph = group.querySelector('.glyph');
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.classList.add('touch-aid');
                        circle.setAttribute('cx', '0');
                        circle.setAttribute('cy', '0');
                        circle.setAttribute('r', '25');
                        circle.setAttribute('stroke', 'none');
                        circle.setAttribute('fill', 'transparent');
                        const halo = glyph.cloneNode();
                        halo.classList.remove('glyph');
                        halo.classList.add('halo');
                        halo.setAttribute('stroke', 'transparent');
                        scalerot.insertBefore(halo, scalerot.firstChild);
                        scalerot.insertBefore(circle, scalerot.firstChild);
                    }
                    svg.innerHTML = el_svg.innerHTML;
                    action();
                };

                // Read the file as text
                reader.readAsText(file);
            }
        }
    });

    function judge() {
        let consonants = 'ᄀᄂᄃᄅᄆᄇᄉᄋᄌᄎᄏᄐᄑᄒ'.split('');
        let vowels = 'ᅡᅣᅥᅧᅩᅭᅮᅲᅳᅵ'.split('');
        let movables = Array.from(document.querySelectorAll('.movable'));
        let vowel_movables = movables.filter((el) => {
            return vowels.includes(el.dataset.jamo);
        }).sort((a, b) => {
            return parseFloat(a.dataset.x) - parseFloat(b.dataset.x);
        });

        let type_v = 'ᅡᅢᅣᅤᅥᅦᅧᅨᅵ'.split('');
        let type_h = 'ᅩᅭᅮᅲᅳ'.split('');
        let type_d = 'ᅪᅫᅬᅯᅰᅱᅴ'.split('');

        let combined_vowels = {
            'ᅡᅵ': 'ᅢ',
            'ᅵᅥ': 'ᅢ',
            'ᅣᅵ': 'ᅤ',
            'ᅵᅧ': 'ᅤ',
            'ᅥᅵ': 'ᅦ',
            'ᅧᅵ': 'ᅨ',
            'ᅩᅡ': 'ᅪ',
            'ᅩᅢ': 'ᅫ',
            'ᅩᅵ': 'ᅬ',
            'ᅮᅥ': 'ᅯ',
            'ᅮᅦ': 'ᅰ',
            'ᅮᅵ': 'ᅱ',
            'ᅳᅵ': 'ᅴ',
        }

        let thres_x = 80;
        let thres_y = 80;

        let valid_vowels = [];

        // 모음 부터 파악
        for(let i = 0; i < vowel_movables.length; i++) {
            let prev_i = i - 1;
            let el_vowel = vowel_movables[i];
            if(prev_i > -1) {
                let cx = 0;
                let cy = 0;

                let el_prev_vowel = vowel_movables[prev_i];
                let linked_elements = [el_prev_vowel, el_vowel];
                let x0 = parseFloat(el_prev_vowel.dataset.x);
                let y0 = parseFloat(el_prev_vowel.dataset.y);
                let x1 = parseFloat(el_vowel.dataset.x);
                let y1 = parseFloat(el_vowel.dataset.y);
                let dx = x1 - x0;
                let dy = y1 - y0;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if(Math.abs(dx) < thres_x && Math.abs(dy) < thres_y) {
                    let key = el_prev_vowel.dataset.jamo + el_vowel.dataset.jamo;
                    let cx = (x0 + x1) / 2;
                    let cy = (y0 + y1) / 2;
                    // ᅫ, ᅰ 경우는 3개를 검사해야 함
                    let combined_vowel = combined_vowels[key];
                    if(i > 1 && (combined_vowel == 'ᅢ' || combined_vowel == 'ᅦ')) {
                        let el_prev_prev_vowel = vowel_movables[i - 2];
                        let x2 = parseFloat(el_prev_prev_vowel.dataset.x);
                        let y2 = parseFloat(el_prev_prev_vowel.dataset.y);
                        let dx2 = x2 - x0;
                        let dy2 = y2 - y0;
                        let dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                        if(Math.abs(dx2) < thres_x && Math.abs(dy2) < thres_y) {
                            key = el_prev_prev_vowel.dataset.jamo + combined_vowel;
                            cx = (x0 + x1 + x2) / 3;
                            cy = (y0 + y1 + y2) / 3;
                            linked_elements.unshift(el_prev_prev_vowel);
                            valid_vowels.pop();
                        }
                    }
                    if(combined_vowels[key]) {
                        valid_vowels.push({
                            'vowel': combined_vowels[key],
                            'cx': cx,
                            'cy': cy,
                            'linked_elements': linked_elements
                        });
                    }

                    el_prev_vowel.querySelector('.halo').setAttribute('stroke', 'red');
                }
                else {
                    valid_vowels.push({
                        'vowel': el_vowel.dataset.jamo,
                        'cx': parseFloat(el_vowel.dataset.x),
                        'cy': parseFloat(el_vowel.dataset.y),
                        'linked_elements': [el_vowel]
                    }); 
                }   
            }
            else {
                valid_vowels.push({
                    'vowel': el_vowel.dataset.jamo,
                    'cx': parseFloat(el_vowel.dataset.x),
                    'cy': parseFloat(el_vowel.dataset.y),
                    'linked_elements': [el_vowel]
                });
            }
        }

        // vaild_vowels를 순회해서 앞 요소의 linked_elements와 현재 요소의 linked_elements가 겹치는게 있으면 앞 요소를 제거
        for (let i = 1; i < valid_vowels.length; i++) {
            const currentVowel = valid_vowels[i];
            const previousVowel = valid_vowels[i - 1];
            const linkedElements = currentVowel.linked_elements;
            const previousLinkedElements = previousVowel.linked_elements;
            const intersection = linkedElements.filter((el) => previousLinkedElements.includes(el));
            if (intersection.length > 0) {
                valid_vowels.splice(i - 1, 1);
                i--;
            }
        }

        console.log(valid_vowels);
    }
    
    init();
    resize();
</script>