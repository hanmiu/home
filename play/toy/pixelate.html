<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Palette Quantization with Drag and Drop</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; justify-content: center; align-items: center; margin: 0; }
        .container { display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .canvas-container { display: flex; gap: 20px; margin-top: 20px; }
        #quantizedCanvas { image-rendering: pixelated; }
        .palette { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 10px; }
        .color-input { width: 30px; height: 30px; padding: 0; border: none; cursor: pointer; }
        #dropZone { border: 2px dashed #ccc; padding: 20px; text-align: center; cursor: pointer; }
        #dropZone.drag-over { background-color: #f0f0f0; }
        #paletteSizeValue { font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <div id="dropZone">
            Drag and drop an image here or click to select
            <input type="file" id="fileInput" accept="image/*" style="display: none;">
        </div>
        <div>
            <label for="paletteSize">Palette Size: </label>
            <input type="range" id="paletteSize" min="2" max="16" value="4">
            <span id="paletteSizeValue">4</span>
        </div>
        <div class="canvas-container">
            <canvas id="originalCanvas"></canvas>
            <canvas id="quantizedCanvas"></canvas>
        </div>
        <div id="palette" class="palette"></div>
    </div>

    <script>
        const originalCanvas = document.getElementById('originalCanvas');
        const quantizedCanvas = document.getElementById('quantizedCanvas');
        const paletteSizeInput = document.getElementById('paletteSize');
        const paletteSizeValue = document.getElementById('paletteSizeValue');
        const paletteContainer = document.getElementById('palette');
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        let originalImageData;
        let palette = [];
        let quantizedWidth, quantizedHeight;

        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    // Resize image if necessary
                    const maxSize = 800;
                    let width = img.width;
                    let height = img.height;
                    if (width > height && width > maxSize) {
                        height *= maxSize / width;
                        width = maxSize;
                    } else if (height > maxSize) {
                        width *= maxSize / height;
                        height = maxSize;
                    }

                    // Set canvas sizes
                    originalCanvas.width = width;
                    originalCanvas.height = height;

                    // Calculate quantized size
                    const maxQuantizedSize = 50;
                    if (width > height) {
                        quantizedWidth = maxQuantizedSize;
                        quantizedHeight = Math.round(height * (maxQuantizedSize / width));
                    } else {
                        quantizedHeight = maxQuantizedSize;
                        quantizedWidth = Math.round(width * (maxQuantizedSize / height));
                    }
                    quantizedCanvas.width = quantizedWidth;
                    quantizedCanvas.height = quantizedHeight;
                    quantizedCanvas.style.width = `${width}px`;
                    quantizedCanvas.style.height = `${height}px`;

                    // Draw original image
                    const ctx = originalCanvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    originalImageData = ctx.getImageData(0, 0, width, height);

                    quantizeImage();
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(file);
        }

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                handleFile(file);
            }
        });

        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        });

        function medianCut(colors, desiredPaletteSize) {
            // Initialize the list of boxes with a single box containing all colors
            let boxes = [getBox(colors)];

            function getBox(colors) {
                let rmin = 255, rmax = 0;
                let gmin = 255, gmax = 0;
                let bmin = 255, bmax = 0;
                for (let i = 0; i < colors.length; i++) {
                    const color = colors[i];
                    if (color[0] < rmin) rmin = color[0];
                    if (color[0] > rmax) rmax = color[0];
                    if (color[1] < gmin) gmin = color[1];
                    if (color[1] > gmax) gmax = color[1];
                    if (color[2] < bmin) bmin = color[2];
                    if (color[2] > bmax) bmax = color[2];
                }
                return { colors: colors, rmin, rmax, gmin, gmax, bmin, bmax };
            }

            while (boxes.length < desiredPaletteSize) {
                // Find the box with the largest color range
                let maxRange = -1;
                let boxIndex = -1;
                for (let i = 0; i < boxes.length; i++) {
                    const box = boxes[i];
                    const rRange = box.rmax - box.rmin;
                    const gRange = box.gmax - box.gmin;
                    const bRange = box.bmax - box.bmin;
                    const range = Math.max(rRange, gRange, bRange);
                    if (range > maxRange && box.colors.length > 1) {
                        maxRange = range;
                        boxIndex = i;
                    }
                }

                if (boxIndex === -1) {
                    // No more boxes can be split
                    break;
                }

                const boxToSplit = boxes[boxIndex];

                // Choose the channel with the largest range
                const rRange = boxToSplit.rmax - boxToSplit.rmin;
                const gRange = boxToSplit.gmax - boxToSplit.gmin;
                const bRange = boxToSplit.bmax - boxToSplit.bmin;

                let channelIndex;
                if (rRange >= gRange && rRange >= bRange) {
                    channelIndex = 0;
                } else if (gRange >= rRange && gRange >= bRange) {
                    channelIndex = 1;
                } else {
                    channelIndex = 2;
                }

                // Sort the colors in the box along the selected channel
                boxToSplit.colors.sort((a, b) => a[channelIndex] - b[channelIndex]);

                // Split the box into two boxes at the median
                const mid = Math.floor(boxToSplit.colors.length / 2);
                const box1Colors = boxToSplit.colors.slice(0, mid);
                const box2Colors = boxToSplit.colors.slice(mid);

                if (box1Colors.length === 0 || box2Colors.length === 0) {
                    // Can't split further, remove the box from consideration
                    boxes.splice(boxIndex, 1);
                    continue;
                }

                const box1 = getBox(box1Colors);
                const box2 = getBox(box2Colors);

                // Replace the original box with the two new boxes
                boxes.splice(boxIndex, 1);
                boxes.push(box1);
                boxes.push(box2);
            }

            // Compute the average color of each box
            const palette = boxes.map(box => {
                const avgColor = box.colors.reduce(
                    (acc, c) => [acc[0] + c[0], acc[1] + c[1], acc[2] + c[2]],
                    [0, 0, 0]
                ).map(v => Math.round(v / box.colors.length));
                return avgColor;
            });

            return palette;
        }

        function quantizeImage(recomputePalette = true) {
            if (!originalImageData) return;

            const { data, width, height } = originalImageData;
            const paletteSize = parseInt(paletteSizeInput.value);

            if (recomputePalette) {
                // Extract colors from the image
                const colors = [];
                for (let i = 0; i < data.length; i += 4) {
                    colors.push([data[i], data[i + 1], data[i + 2]]);
                }

                // Apply the Median Cut algorithm
                palette = medianCut(colors, paletteSize);
                updatePaletteUI();
            }

            // Quantize the image using the current palette
            const ctx = quantizedCanvas.getContext('2d');
            const quantized = ctx.createImageData(quantizedWidth, quantizedHeight);

            for (let y = 0; y < quantizedHeight; y++) {
                for (let x = 0; x < quantizedWidth; x++) {
                    const i = (y * quantizedWidth + x) * 4;
                    const sourceX = Math.floor(x * width / quantizedWidth);
                    const sourceY = Math.floor(y * height / quantizedHeight);
                    const sourceI = (sourceY * width + sourceX) * 4;
                    const sourceColor = [data[sourceI], data[sourceI + 1], data[sourceI + 2]];

                    // Find the closest palette color
                    let minDistance = Infinity;
                    let closestColor = palette[0];
                    for (let j = 0; j < palette.length; j++) {
                        const palColor = palette[j];
                        const dist = colorDistance(sourceColor, palColor);
                        if (dist < minDistance) {
                            minDistance = dist;
                            closestColor = palColor;
                        }
                    }

                    quantized.data[i] = closestColor[0];
                    quantized.data[i + 1] = closestColor[1];
                    quantized.data[i + 2] = closestColor[2];
                    quantized.data[i + 3] = 255;
                }
            }

            ctx.putImageData(quantized, 0, 0);
        }

        function colorDistance(c1, c2) {
            return Math.pow(c1[0] - c2[0], 2) +
                   Math.pow(c1[1] - c2[1], 2) +
                   Math.pow(c1[2] - c2[2], 2);
        }

        function updatePaletteUI() {
            paletteContainer.innerHTML = '';
            palette.forEach((color, index) => {
                const input = document.createElement('input');
                input.type = 'color';
                input.className = 'color-input';
                input.value = `#${color[0].toString(16).padStart(2, '0')}${color[1].toString(16).padStart(2, '0')}${color[2].toString(16).padStart(2, '0')}`;
                input.addEventListener('change', (e) => handlePaletteChange(index, e.target.value));
                paletteContainer.appendChild(input);
            });
        }

        function handlePaletteChange(index, newColor) {
            palette[index] = newColor.slice(1).match(/.{2}/g).map(x => parseInt(x, 16));
            quantizeImage(false); // Do not recompute the palette
        }

        paletteSizeInput.addEventListener('input', () => {
            paletteSizeValue.textContent = paletteSizeInput.value;
            quantizeImage(true); // Recompute the palette
        });
    </script>
</body>
</html>