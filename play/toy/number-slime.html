<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
    <title>숫자 슬라임</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Days+One&display=swap');
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        canvas {
            width: 100vw;
            height: 100vh;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            width: 100%;
            position: fixed;
            bottom: 0;
            z-index: 10;
        }
        .control {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        label {
            margin-bottom: 5px;
        }
        input[type="range"], input[type="number"] {
            width: 100px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #container { position: relative; }
        canvas { position: absolute; top: 0; left: 0; }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="webglCanvas"></canvas>
        <canvas id="canvas"></canvas>
    </div>
    <div class="controls" style="display: none;">
        <div class="control">
            <label for="particleCount">Particle Count:</label>
            <input type="number" id="particleCount" min="10" max="1000" value="20">
        </div>
        <div class="control">
            <label for="particleSize">Particle Size:</label>
            <input type="range" id="particleSize" min="2" max="20" value="20">
        </div>
        <div class="control">
            <label for="repulsionFactor">Repulsion Factor:</label>
            <input type="range" id="repulsionFactor" min="0" max="100" value="79">
        </div>
        <div class="control">
            <label for="attractionDistance">Attraction Distance:</label>
            <input type="range" id="attractionDistance" min="0" max="200" value="73">
        </div>
        <div class="control">
            <label for="attractionFactor">Attraction Factor:</label>
            <input type="range" id="attractionFactor" min="0" max="100" value="76">
        </div>
        <div class="control">
            <label for="clusterEpsilon">Cluster Epsilon:</label>
            <input type="range" id="clusterEpsilon" min="10" max="100" value="50">
        </div>
        <div class="control">
            <label for="clusterMinPts">Cluster Min Points:</label>
            <input type="number" id="clusterMinPts" min="1" max="10" value="1">
        </div>
    </div>
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec2 u_resolution;
        uniform vec2 u_circles[20];
        uniform vec3 u_colors[20];
        uniform int u_circleCount;
        uniform float u_tightness;

        float metaball(vec2 p, vec2 center, float radius) {
            return radius * radius / dot(p - center, p - center);
        }

        vec3 backgroundGradient(vec2 uv) {
            float t = uv.y;
            return mix(vec3(0.1, 0.2, 0.3), vec3(0.5, 0.7, 0.9), t);
            // return vec3(1.0);
        }

        void main() {
            vec2 uv = (2.0 * gl_FragCoord.xy - u_resolution) / u_resolution.y;
            vec3 blobColor = vec3(0.0);
            vec3 mixedColor = vec3(0.0);
            float maxInfluence = 0.0;
            float totalWeight = 0.0;
            float influence = 0.0;
            for (int i = 0; i < 20; i++) {
                if (i >= u_circleCount) break;
                influence = metaball(uv, u_circles[i], 0.05); 
                if (influence > maxInfluence) {
                    maxInfluence = influence;
                    blobColor = u_colors[i];
                }
                mixedColor += influence * u_colors[i];
                totalWeight += influence;
            }

            float threshold = u_tightness;
            float value = smoothstep(threshold - 0.05, threshold, totalWeight);
            value = clamp(value, 0.0, 1.0);

            vec3 backgroundColor = backgroundGradient(uv * 0.5 + 0.5);
            float smoothValue = 0.0;
            if (totalWeight > 0.0) {
                mixedColor /= totalWeight; // Normalize the mixed color by the total influence
                blobColor = mix(blobColor, mixedColor, smoothValue); // Mix the blob color with the mixed color
            }
            //blobColor = mix(backgroundColor, vec3(influence), value);

            gl_FragColor = vec4(mix(backgroundColor, blobColor, value), 1.0);
        }
    </script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        let selectedParticle = null;
        let clusters = [];
        let old_clusters = clusters;
        let currentClusterId = 0;
        let nearestCluster = null;
        let lastMousePos = { x: 0, y: 0 };
        let mousePos = { x: 0, y: 0 };
        let mouseOffset = { x: 0, y: 0 };
        let mouseVelocity = { x: 0, y: 0 };
        let paused = false;
        const particleCountInput = document.getElementById('particleCount');
        const particleSizeInput = document.getElementById('particleSize');
        const repulsionFactorInput = document.getElementById('repulsionFactor');
        const attractionDistanceInput = document.getElementById('attractionDistance');
        const attractionFactorInput = document.getElementById('attractionFactor');
        const clusterEpsilonInput = document.getElementById('clusterEpsilon');
        const clusterMinPtsInput = document.getElementById('clusterMinPts');

        const webglCanvas = document.getElementById('webglCanvas');
        const gl = webglCanvas.getContext('webgl');
        let main_program = null;
        let tightness = 1;
        let randerGL = null;

        class Particle {
            constructor(x, y, size, hsl, to_hsl) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.hsl = hsl;
                this.to_hsl = to_hsl;
                this.color = hslToNormalizedRgb(hsl.h, hsl.s, hsl.l);
                this.vx = 0;
                this.vy = 0;
                this.cluster = -1; // -1 means no cluster
            }

            update() {
                if (this !== selectedParticle && !paused) {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < this.size || this.x > canvas.width - this.size) this.vx *= -0.5;
                    if (this.y < this.size || this.y > canvas.height - this.size) this.vy *= -0.5;

                    this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                    this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));

                    this.vx *= 0.99;
                    this.vy *= 0.99;
                }

                this.hsl.h += (this.to_hsl.h - this.hsl.h) * 0.1;
                this.hsl.s += (this.to_hsl.s - this.hsl.s) * 0.1;
                this.hsl.l += (this.to_hsl.l - this.hsl.l) * 0.1;
                this.color = hslToNormalizedRgb(this.hsl.h, this.hsl.s, this.hsl.l);
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size *0.5, 0, Math.PI * 2);
                ctx.fillStyle = this === selectedParticle ? 'rgba(255, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.0)';
                ctx.fill();
                ctx.strokeStyle = this === selectedParticle ? 'red' : 'rgba(0, 0, 255, 1)';
                ctx.closePath();
                //ctx.stroke();
            }

            isPointInside(x, y) {
                const dx = this.x - x;
                const dy = this.y - y;
                return dx * dx + dy * dy <= this.size * this.size;
            }
        }

        function initParticles() {
            particles = [];
            const count = parseInt(particleCountInput.value);
            const size = parseInt(particleSizeInput.value);
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(
                    Math.random() * (canvas.width - 2 * size) + size,
                    Math.random() * (canvas.height - 2 * size) + size,
                    size,
                    generateBrightGreenColor(i / (count - 1)),
                    generateBrightGreenColor(i / (count - 1))
                ));
            }

            initWebGL();
        }

        function applyForces() {
            const repulsionFactor = parseFloat(repulsionFactorInput.value) / 1000;
            const attractionDist = parseFloat(attractionDistanceInput.value);
            const attractionFactor = parseFloat(attractionFactorInput.value) / 10000;

            for (let i = 0; i < particles.length - 1; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    if (particles[i] === selectedParticle || particles[j] === selectedParticle) continue;

                    const dx = particles[j].x - particles[i].x;
                    const dy = particles[j].y - particles[i].y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);
                    const minDist = particles[i].size + particles[j].size;

                    if (dist < minDist) {
                        // Strong repulsion to prevent overlap
                        const force = repulsionFactor * (minDist - dist) / dist;
                        const fx = dx * force;
                        const fy = dy * force;
                        particles[i].vx -= fx;
                        particles[i].vy -= fy;
                        particles[j].vx += fx;
                        particles[j].vy += fy;
                    } else if (dist < attractionDist) {
                        // Weak attraction
                        const force = attractionFactor * (dist - minDist) / dist;
                        const fx = dx * force;
                        const fy = dy * force;
                        particles[i].vx += fx;
                        particles[i].vy += fy;
                        particles[j].vx -= fx;
                        particles[j].vy -= fy;
                    }
                }
            }
        }

        function dbscan() {
            const epsilon = parseFloat(clusterEpsilonInput.value);
            const minPts = parseInt(clusterMinPtsInput.value);
            let clusterIndex = 0;
            if(clusters.length > 0) {
                old_clusters = clusters;
            }
            clusters = [];

            // Reset all clusters
            for (let particle of particles) {
                particle.cluster = -1;
            }

            for (let particle of particles) {
                if (particle.cluster !== -1) continue;

                const neighborPts = getNeighbors(particle, epsilon);
                if (neighborPts.length < minPts) {
                    particle.cluster = -1; // Noise
                } else {
                    expandCluster(particle, neighborPts, clusterIndex, epsilon, minPts);
                    clusterIndex++;
                }
            }

            // Calculate cluster centers
            for (let i = 0; i < clusterIndex; i++) {
                let sumX = 0, sumY = 0, count = 0;
                for (let particle of particles) {
                    if (particle.cluster === i) {
                        sumX += particle.x;
                        sumY += particle.y;
                        count++;
                    }
                }
                if (count > 0) {
                    let nearestCluster = null;
                    if(old_clusters.length > 0) {
                        let minDist = Number.MAX_VALUE;
                        for (let j = 0; j < old_clusters.length; j++) {
                            let dx = old_clusters[j].x - sumX / count;
                            let dy = old_clusters[j].y - sumY / count;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDist) {
                                minDist = dist;
                                nearestCluster = old_clusters[j];
                            }
                        }
                    }
                    // if (nearestCluster) {
                        
                    // }
                    clusters.push({x: sumX / count, y: sumY / count, index: i, id: -1});
                }
            }
        }

        function getNeighbors(particle, epsilon) {
            return particles.filter(p => 
                p !== particle && 
                Math.sqrt((p.x - particle.x)**2 + (p.y - particle.y)**2) <= epsilon
            );
        }

        function expandCluster(particle, neighborPts, clusterIndex, epsilon, minPts) {
            particle.cluster = clusterIndex;

            for (let i = 0; i < neighborPts.length; i++) {
                let neighborParticle = neighborPts[i];
                if (neighborParticle.cluster === -1) {
                    neighborParticle.cluster = clusterIndex;
                    let neighborNeighborPts = getNeighbors(neighborParticle, epsilon);
                    if (neighborNeighborPts.length >= minPts) {
                        neighborPts = neighborPts.concat(neighborNeighborPts);
                    }
                }
            }
        }

        function moveCluster(particle, dx, dy) {
            const speed = Math.sqrt(dx*dx + dy*dy);
            const maxSpeed = 5; // Adjust this value to change the threshold for cluster separation
            const moveFactor = Math.max(0, 1 - speed / maxSpeed);

            for (let p of particles) {
                if(p.cluster === -1) continue;
                if (p.cluster === particle.cluster && p !== particle) {
                    p.vx = dx * moveFactor;
                    p.vy = dy * moveFactor;
                }
            }
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            applyForces();
            dbscan();

            if (nearestCluster && Math.random() < 0.1) {
                const pos = mousePos;
                for (let particle of particles) {
                    if (particle.cluster === nearestCluster.index) {
                        let dx = pos.x - particle.x;
                        let dy = pos.y - particle.y;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        let force = 1 / dist * 3;
                        particle.vx = dx * force;
                        particle.vy = dy * force;
                    }
                }
            }

            ctx.font = '25px Days One';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let particle of particles) {
                particle.update();
                particle.draw();
                if(particle.cluster == -1) {
                    ctx.fillStyle = 'black';
                    ctx.fillText('1', particle.x, particle.y);
                }
            }

            // Draw cluster indices
            for (let cluster of clusters) {
                let clusterParticles = particles.filter(p => p.cluster === cluster.index);
                let count = clusterParticles.length;             

                // Draw eyes if there are at least 2 particles in the cluster
                if (count >= 2) {
                    let [x0, y0] = [clusterParticles[0].x, clusterParticles[0].y];
                    let [x1, y1] = [clusterParticles[1].x, clusterParticles[1].y];
                    // drawEye(clusterParticles[0].x, clusterParticles[0].y, clusterParticles[1].x, clusterParticles[1].y);
                    // drawEye(clusterParticles[1].x, clusterParticles[1].y, clusterParticles[0].x, clusterParticles[0].y);
                    // drawEye2(clusterParticles[0].x, clusterParticles[0].y, clusterParticles[1].x, clusterParticles[1].y, mousePos.x, mousePos.y);
                    // drawEye2(clusterParticles[1].x, clusterParticles[1].y, clusterParticles[0].x, clusterParticles[0].y, mousePos.x, mousePos.y);
                    drawEye3(clusterParticles[0].x, clusterParticles[0].y, mousePos.x, mousePos.y);
                    drawEye3(clusterParticles[1].x, clusterParticles[1].y, mousePos.x, mousePos.y);

                    // ctx.fillStyle = 'red';
                    // ctx.fillText(cluster.id, cluster.x, cluster.y);
                    ctx.fillStyle = 'black';

                     // Calculate midpoint
                    let mx = (x0 + x1) / 2;
                    let my = (y0 + y1) / 2;

                    // Calculate the vector (x1 - x0, y1 - y0)
                    let dx = x1 - x0;
                    let dy = y1 - y0;

                    // Calculate orthogonal vector
                    // Use (-dy, dx) or (dy, -dx)
                    let orthoX = dy;
                    let orthoY = -dx;

                    // Determine which direction to move in
                    let o0 = [-dy, dx];
                    let o1 = [dy, -dx];

                    // Normalize the orthogonal vector to 30 units length
                    let length = Math.sqrt(orthoX * orthoX + orthoY * orthoY);
                    let factor = 30 / length;
                    orthoX *= factor;
                    orthoY *= factor;

                    // Calculate new position for fillText
                    let fx = mx + orthoX;
                    let fy = my + orthoY;

                    // Draw text
                    ctx.fillStyle = 'black';
                    ctx.fillText(count, fx, fy);

                    // color change
                    let f = count / 19;
                    let h = f * 0.9;
                    clusterParticles.forEach(p => {
                        let s = p.hsl.s;
                        let l = p.hsl.l;
                        p.to_hsl = { h, s, l };
                    });
                }
            }

            if(renderGL) {
                renderGL();
            }

            requestAnimationFrame(update);
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function getTouchPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.touches[0].clientX - rect.left,
                y: evt.touches[0].clientY - rect.top
            };
        }

        function onDown(e) {
            const pos = e.touches ? getTouchPos(canvas, e) : getMousePos(canvas, e);
            mousePos = pos;
            if(e.touches) e.preventDefault();
            mouseOffset = { x: 0, y: 0 };
            selectedParticle = null;
            for (let particle of particles) {
                // radius 50px 안에 있는 입자 중 pos와 가장 가까운 입자 선택
                let dx = particle.x - pos.x;
                let dy = particle.y - pos.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 50 && (!selectedParticle || dist < selectedParticle.dist)) {
                    selectedParticle = particle;
                    selectedParticle.dist = dist;
                    lastMousePos = pos;
                    mouseOffset = { x: pos.x - particle.x, y: pos.y - particle.y };
                }
            }
            if(!selectedParticle) {
                // nearest cluster
                nearestCluster = null;
                let minDist = Number.MAX_VALUE;
                for (let cluster of clusters) {
                    let dx = cluster.x - pos.x;
                    let dy = cluster.y - pos.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist && dist < 500) {
                        minDist = dist;
                        nearestCluster = cluster;
                    }
                }
                if (nearestCluster) {
                    for (let particle of particles) {
                        if (particle.cluster === nearestCluster.index) {
                            let dx = pos.x - particle.x;
                            let dy = pos.y - particle.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            let force = 1 / dist;
                            particle.vx = dx * force;
                            particle.vy = dy * force;
                        }
                    }
                }
            }
        }

        function onMove(e) {
            const pos = e.touches ? getTouchPos(canvas, e) : getMousePos(canvas, e);
            mousePos = pos;
            if (selectedParticle) {
                if(e.touches) e.preventDefault();
                const dx = pos.x - lastMousePos.x;
                const dy = pos.y - lastMousePos.y;

                selectedParticle.x = pos.x - mouseOffset.x;
                selectedParticle.y = pos.y - mouseOffset.y;
                selectedParticle.vx = 0;
                selectedParticle.vy = 0;

                moveCluster(selectedParticle, dx, dy);

                mouseVelocity = {
                    x: dx,
                    y: dy
                };

                lastMousePos = pos;
            }
        }

        function onUp() {
            if (selectedParticle) {
                selectedParticle.vx = mouseVelocity.x;
                selectedParticle.vy = mouseVelocity.y;
            }
            selectedParticle = null;
            nearestCluster = null;
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            webglCanvas.width = canvas.width;
            webglCanvas.height = canvas.height;
            if(gl && main_program) {
                gl.useProgram(main_program);
                gl.viewport(0, 0, canvas.width, canvas.height);
                const resolutionUniformLocation = gl.getUniformLocation(main_program, "u_resolution");
                gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
            }
            
            // initParticles();
        }

        window.addEventListener('resize', resizeCanvas);

        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onUp);
        canvas.addEventListener('mouseleave', onUp);
        
        canvas.addEventListener('touchstart', onDown);
        canvas.addEventListener('touchmove', onMove);
        canvas.addEventListener('touchend', onUp);

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        resizeCanvas();
        initParticles();
        update();

        particleCountInput.addEventListener('change', initParticles);
        particleSizeInput.addEventListener('change', initParticles);

        function drawEye(x, y, otherX, otherY) {
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();

            const angle = Math.atan2(otherY - y, otherX - x);
            const pupilX = x + Math.cos(angle) * 3;
            const pupilY = y + Math.sin(angle) * 3;
            ctx.fillStyle = "blue";
            ctx.beginPath();
            ctx.arc(pupilX, pupilY, 7, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEye2(x, y, otherX, otherY, targetX, targetY) {
            // 눈 전체 그리기
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();

            // 시선 방향 계산
            const eyeCenterX = (x + otherX) / 2;
            const eyeCenterY = (y + otherY) / 2;
            const angle = Math.atan2(targetY - eyeCenterY, targetX - eyeCenterX);

            // 눈동자 위치 계산
            const maxDistance = 3; // 눈동자가 움직일 수 있는 최대 거리
            const pupilX = x + Math.cos(angle) * maxDistance;
            const pupilY = y + Math.sin(angle) * maxDistance;

            // 눈동자 그리기
            ctx.fillStyle = "blue";
            ctx.beginPath();
            ctx.arc(pupilX, pupilY, 7, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEye3(x, y, targetX, targetY) {
            // 눈 전체 그리기
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();

            // 시선 방향 계산
            const angle = Math.atan2(targetY - y, targetX - x);

            // 눈동자 위치 계산
            const maxDistance = 3; // 눈동자가 움직일 수 있는 최대 거리
            let distance = Math.min(maxDistance, Math.hypot(targetX - x, targetY - y) / 10);
            const pupilX = x + Math.cos(angle) * distance;
            const pupilY = y + Math.sin(angle) * distance;

            // 눈동자 그리기
            ctx.fillStyle = "blue";
            ctx.beginPath();
            ctx.arc(pupilX, pupilY, 7, 0, Math.PI * 2);
            ctx.fill();
        }

        //----

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }

        function initWebGL() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            webglCanvas.width = canvas.width = width;
            webglCanvas.height = canvas.height = height;
            gl.viewport(0, 0, width, height);

            const vertexShaderSource = document.getElementById('vertexShader').text;
            const fragmentShaderSource = document.getElementById('fragmentShader').text;

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            const program = createProgram(gl, vertexShader, fragmentShader);
            main_program = program;
            gl.useProgram(program);

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
            gl.uniform2f(resolutionUniformLocation, width, height);

            const circlesUniformLocation = gl.getUniformLocation(program, "u_circles");
            const colorsUniformLocation = gl.getUniformLocation(program, "u_colors");
            const circleCountUniformLocation = gl.getUniformLocation(program, "u_circleCount");
            const tightnessUniformLocation = gl.getUniformLocation(program, "u_tightness");

            //createCircles(circleCount);

            function render() {
                gl.clear(gl.COLOR_BUFFER_BIT);

                const circlePositions = new Float32Array(particles.flatMap(c => [
                    (2.0 * c.x - canvas.width) / canvas.height,
                    (2.0 * (canvas.height - c.y) - canvas.height) / canvas.height
                ]));
                gl.uniform2fv(circlesUniformLocation, circlePositions);

                const circleColors = new Float32Array(particles.flatMap(c => [
                    c.color.r,
                    c.color.g,
                    c.color.b
                ]));
                gl.uniform3fv(colorsUniformLocation, circleColors);

                gl.uniform1i(circleCountUniformLocation, particles.length);
                gl.uniform1f(tightnessUniformLocation, tightness);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            renderGL = render;
        }


        function generateBrightGreenColor(f) {
            // //const h = 80 + Math.random() * 60; // Hue range from 80 to 140 (yellow-green to green-cyan)
            // const h = 0 + Math.random() * 360; // Hue range from 80 to 140 (yellow-green to green-cyan)
            // const s = 70 + Math.random() * 30; // Saturation range from 70% to 100%
            // const l = 40 + Math.random() * 30; // Lightness range from 40% to 70%
            // return hslToRgb(h, s, l);

            return {
                h: f * 0.9,
                s: 0.3 + f * 0.7,
                l: 0.2 + f * 0.3
            };
        }

        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        function hslToNormalizedRgb(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return {
                r: r,
                g: g,
                b: b
            };
        }

        function hslToRgb(h, s, l) {
            const rgb = hslToNormalizedRgb(h, s, l);
            return {
                r: Math.round(rgb.r * 255),
                g: Math.round(rgb.g * 255),
                b: Math.round(rgb.b * 255)
            };
        }
    </script>
</body>
</html>