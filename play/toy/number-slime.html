<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
    <title>숫자 슬라임</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Days+One&display=swap');
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            width: 100%;
            position: fixed;
            bottom: 0;
            z-index: 10;
        }
        .control {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        label {
            margin-bottom: 5px;
        }
        input[type="range"], input[type="number"] {
            width: 100px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #container { position: relative; }
        canvas { position: absolute; top: 0; left: 0; }
        #logotype {
            position: absolute;
            left: 20px;
            bottom: 20px;
            height: 20px;
            opacity: 0.5;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="webglCanvas"></canvas>
        <canvas id="canvas"></canvas>
    </div>
    <div class="controls" style="display: none;">
        <div class="control">
            <label for="particleCount">Particle Count:</label>
            <input type="number" id="particleCount" min="10" max="1000" value="20">
        </div>
        <div class="control">
            <label for="particleSize">Particle Size:</label>
            <input type="range" id="particleSize" min="2" max="20" value="20">
        </div>
        <div class="control">
            <label for="repulsionFactor">Repulsion Factor:</label>
            <input type="range" id="repulsionFactor" min="0" max="100" value="79">
        </div>
        <div class="control">
            <label for="attractionDistance">Attraction Distance:</label>
            <input type="range" id="attractionDistance" min="0" max="200" value="73">
        </div>
        <div class="control">
            <label for="attractionFactor">Attraction Factor:</label>
            <input type="range" id="attractionFactor" min="0" max="100" value="76">
        </div>
        <div class="control">
            <label for="clusterEpsilon">Cluster Epsilon:</label>
            <input type="range" id="clusterEpsilon" min="10" max="100" value="50">
        </div>
        <div class="control">
            <label for="clusterMinPts">Cluster Min Points:</label>
            <input type="number" id="clusterMinPts" min="1" max="10" value="1">
        </div>
    </div>
    <img id="logotype">
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec3 u_mouse;
        uniform vec2 u_resolution;
        uniform vec2 u_circles[20];
        uniform vec3 u_colors[20];
        uniform int u_circleCount;
        uniform float u_tightness;
        uniform float u_time;

        float metaball(vec2 p, vec2 center, float radius) {
            return radius * radius / dot(p - center, p - center);
        }

        vec3 backgroundGradient(vec2 uv) {
            float t = uv.y;
            // return mix(vec3(0.1, 0.2, 0.3), vec3(0.5, 0.7, 0.9), t);
            //uv = floor(uv * 20.0) / 20.0;
            float d = length(uv - u_mouse.xy);
            d = 0.1 / (d + 1e-3);
            d += (sin(atan(uv.y - u_mouse.y, uv.x - u_mouse.x) * 5.0) * 0.5 + 0.5) * 0.1;
            float c = sin(d * 50.0 - u_time) * 0.5 + 0.5 + d;
            // gamma correction
            c = pow(c, 1.0 / 2.2);
            float factor = 0.0;
            if(u_mouse.z > 0.0) {
                factor = 0.2;
            }
            return clamp(vec3(1.0 - c) * 0.5, 0.0, 1.0) * factor;
        }

        void main() {
            vec2 uv = (2.0 * gl_FragCoord.xy - u_resolution) / u_resolution.y;
            vec3 blobColor = vec3(0.0);
            vec3 mixedColor = vec3(0.0);
            float maxInfluence = 0.0;
            float totalWeight = 0.0;
            float influence = 0.0;
            for (int i = 0; i < 20; i++) {
                if (i >= u_circleCount) break;
                influence = metaball(uv, u_circles[i], 0.05); 
                if (influence > maxInfluence) {
                    maxInfluence = influence;
                    blobColor = u_colors[i];
                }
                mixedColor += influence * u_colors[i];
                totalWeight += influence;
            }

            float threshold = u_tightness;
            float value = smoothstep(threshold - 0.05, threshold, totalWeight);
            value = clamp(value, 0.0, 1.0);

            vec3 backgroundColor = backgroundGradient(uv);
            float smoothValue = 0.5;
            if (totalWeight > 0.0) {
                mixedColor /= totalWeight; // Normalize the mixed color by the total influence
                blobColor = mix(blobColor, mixedColor, smoothValue); // Mix the blob color with the mixed color
            }
            //blobColor = mix(backgroundColor, vec3(influence), value);

            gl_FragColor = vec4(mix(backgroundColor, blobColor, value), 1.0);
        }
    </script>
    <script>
        let el_logotype = document.querySelector('#logotype');
        let logo_svg_str = `<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 305 100" version="1.1" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:1.5;"><g transform="matrix(0.132046,0,0,0.132046,-275.898,-181.837)"><path d="M2289.38,1553.11C2289.38,1553.11 2292.98,1574.84 2295.55,1603.89" style="fill:none;stroke:black;stroke-width:31.55px;"></path></g><g transform="matrix(0.138417,0,0,0.125615,-215.341,-148.706)"><path d="M1824.42,1568.64C1824.42,1531.91 1794.6,1502.1 1757.88,1502.1L1735.13,1502.1C1698.4,1502.1 1668.59,1531.91 1668.59,1568.64C1668.59,1605.37 1698.4,1635.18 1735.13,1635.18L1757.88,1635.18C1794.6,1635.18 1824.42,1605.37 1824.42,1568.64Z" style="fill:none;stroke:black;stroke-width:31.52px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,-234.97,-149.014)"><path d="M2555.2,1518.19L2555.2,1842.53" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,-231.778,-165.71)"><path d="M2142.87,1724.47L2408.16,1724.47" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,-36.6926,-181.98)"><path d="M482.378,2192.03C482.378,2232.68 471.655,2280.67 551.585,2280.43L835.645,2280.43" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,-27.4323,-152.336)"><path d="M726.04,1724.47L813.8,1724.47" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.167914,0,0,-0.167914,-121.496,319.866)"><path d="M2289.38,1553.11C2289.38,1553.11 2292.98,1574.84 2295.55,1603.89" style="fill:none;stroke:black;stroke-width:24.81px;"></path></g><g transform="matrix(0.138417,0,0,0.125615,21.1762,-165.445)"><path d="M1824.42,1568.64C1824.42,1531.91 1794.6,1502.1 1757.88,1502.1L1735.13,1502.1C1698.4,1502.1 1668.59,1531.91 1668.59,1568.64C1668.59,1605.37 1698.4,1635.18 1735.13,1635.18L1757.88,1635.18C1794.6,1635.18 1824.42,1605.37 1824.42,1568.64Z" style="fill:none;stroke:black;stroke-width:31.52px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,198.954,-181.98)"><path d="M482.378,2192.03C482.378,2232.68 471.655,2280.67 551.585,2280.43L835.645,2280.43" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,2.37791,-149.014)"><path d="M2555.2,1518.19L2555.2,1872.19" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,199.935,-138.281)"><path d="M726.04,1724.47L813.8,1724.47" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,-59.8431,-148.992)"><path d="M2703.12,1753.94C2845.41,1760.9 2927.01,1766.21 2998.72,1724.47" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.173765,0,0,0.168083,-145.561,-229.091)"><path d="M1824.42,1568.64C1824.42,1531.91 1794.6,1502.1 1757.88,1502.1L1735.13,1502.1C1698.4,1502.1 1668.59,1531.91 1668.59,1568.64C1668.59,1605.37 1698.4,1635.18 1735.13,1635.18L1757.88,1635.18C1794.6,1635.18 1824.42,1605.37 1824.42,1568.64Z" style="fill:none;stroke:black;stroke-width:24.37px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,-45.8206,-149.203)"><path d="M1736.22,1991.09C1736.22,1862.33 1745.24,1793.49 1663.19,1790.81C1600.94,1788.78 1567.65,1753.84 1564.35,1718.29" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(-0.113461,0,0,0.113461,361.661,-149.151)"><path d="M1736.76,1991.09C1736.76,1862.33 1745.24,1793.49 1663.19,1790.81C1600.94,1788.78 1567.65,1759.84 1564.35,1724.29" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,-53.0782,-149.568)"><path d="M2289.38,1553.11C2289.38,1553.11 2308.91,1670.79 2289.38,1724.47C2269.72,1778.49 2171.6,1875.79 2171.44,1877.27" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(-0.113461,0,0,0.113461,466.598,-149.568)"><path d="M2290.86,1724.47L2173.04,1877.27" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,-56.4968,-148.992)"><path d="M2555.2,1518.19L2555.2,1960.22" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,-53.1885,-162.323)"><path d="M2172.41,1724.47L2408.16,1724.47" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113461,0,0,0.113461,-172.361,-148.992)"><path d="M2555.2,1518.19L2555.2,1960.22" style="fill:none;stroke:black;stroke-width:36.72px;"></path></g><g transform="matrix(0.113459,0,0,0.103146,-35.0422,-129.724)"><rect x="991.31" y="1548.04" width="202.433" height="324.155" style="fill:none;stroke:black;stroke-width:38.43px;"></rect></g></svg>`;
        el_logotype.src = `data:image/svg+xml;utf8,${logo_svg_str}`;
        document.querySelector('#logotype').addEventListener('click', (event) => {
            window.open('https://www.hanmiu.cc', '_blank');
        });

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        let selectedParticle = null;
        let clusters = []; 
        let nearestCluster = null;
        let slimes = [];
        let mouseInfo = {
            x: 0,
            y: 0,
            lastX: 0,
            lastY: 0,
            offsetX: 0,
            offsetY: 0,
            velocityX: 0,
            velocityY: 0,
            downX: 0,
            downY: 0,
            isDown: false,
            isDividingMode: false,
            tick: 0,
            trail: [],
        };
        let dividers = [];
        let paused = false;
        let time = 0;

        const particleCountInput = document.getElementById('particleCount');
        const particleSizeInput = document.getElementById('particleSize');
        const repulsionFactorInput = document.getElementById('repulsionFactor');
        const attractionDistanceInput = document.getElementById('attractionDistance');
        const attractionFactorInput = document.getElementById('attractionFactor');
        const clusterEpsilonInput = document.getElementById('clusterEpsilon');
        const clusterMinPtsInput = document.getElementById('clusterMinPts');

        const webglCanvas = document.getElementById('webglCanvas');
        const gl = webglCanvas.getContext('webgl');
        let main_program = null;
        let tightness = 1;
        let randerGL = null;

        const eye_colors = [
            'blue',
            'teal',
            'green',
            'navy',
            'purple',
            'red',
            'yellow',
            'olive',
            'cyan',
            'lime',
            'aqua',
            'maroon',
            'fuchsia',
        ];

        class Particle {
            constructor(x, y, size, hsl, to_hsl) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.hsl = hsl;
                this.to_hsl = to_hsl;
                this.color = hslToNormalizedRgb(hsl.h, hsl.s, hsl.l);
                this.vx = 0;
                this.vy = 0;
                this.cluster = -1; // -1 means no cluster
            }

            update() {
                if (this !== selectedParticle && !paused) {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < this.size || this.x > canvas.width - this.size) this.vx *= -0.5;
                    if (this.y < this.size || this.y > canvas.height - this.size) this.vy *= -0.5;

                    this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                    this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));

                    this.vx *= 0.99;
                    this.vy *= 0.99;
                }

                this.hsl.h += (this.to_hsl.h - this.hsl.h) * 0.1;
                this.hsl.s += (this.to_hsl.s - this.hsl.s) * 0.1;
                this.hsl.l += (this.to_hsl.l - this.hsl.l) * 0.1;
                this.color = hslToNormalizedRgb(this.hsl.h, this.hsl.s, this.hsl.l);
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size *0.5, 0, Math.PI * 2);
                ctx.fillStyle = this === selectedParticle ? 'rgba(255, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.0)';
                ctx.fill();
                ctx.strokeStyle = this === selectedParticle ? 'red' : 'rgba(0, 0, 255, 1)';
                ctx.closePath();
                //ctx.stroke();
            }

            isPointInside(x, y) {
                const dx = this.x - x;
                const dy = this.y - y;
                return dx * dx + dy * dy <= this.size * this.size;
            }
        }

        function initParticles() {
            particles = [];
            const count = parseInt(particleCountInput.value);
            const size = parseInt(particleSizeInput.value);
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(
                    Math.random() * (canvas.width - 2 * size) + size,
                    Math.random() * (canvas.height - 2 * size) + size,
                    size,
                    generateBrightGreenColor(i / (count - 1)),
                    generateBrightGreenColor(i / (count - 1))
                ));
            }

            initWebGL();
        }

        function applyForces() {
            const repulsionFactor = parseFloat(repulsionFactorInput.value) / 1000;
            const attractionDist = parseFloat(attractionDistanceInput.value);
            const attractionFactor = parseFloat(attractionFactorInput.value) / 10000;

            for (let i = 0; i < particles.length - 1; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    if (particles[i] === selectedParticle || particles[j] === selectedParticle) continue;

                    const dx = particles[j].x - particles[i].x;
                    const dy = particles[j].y - particles[i].y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);
                    const minDist = particles[i].size + particles[j].size;

                    if (dist < minDist) {
                        // Strong repulsion to prevent overlap
                        const force = repulsionFactor * (minDist - dist) / dist;
                        const fx = dx * force;
                        const fy = dy * force;
                        particles[i].vx -= fx;
                        particles[i].vy -= fy;
                        particles[j].vx += fx;
                        particles[j].vy += fy;
                    } else if (dist < attractionDist) {
                        // Weak attraction
                        const force = attractionFactor * (dist - minDist) / dist;
                        const fx = dx * force;
                        const fy = dy * force;
                        particles[i].vx += fx;
                        particles[i].vy += fy;
                        particles[j].vx -= fx;
                        particles[j].vy -= fy;
                    }
                }
            }
        }

        let currentSlimeId = 0;
        function dbscan() {
            const epsilon = parseFloat(clusterEpsilonInput.value);
            const minPts = parseInt(clusterMinPtsInput.value);
            let clusterIndex = 0;
            clusters = [];

            // Reset all clusters
            for (let particle of particles) {
                particle.cluster = -1;
            }

            for (let particle of particles) {
                if (particle.cluster !== -1) continue;

                const neighborPts = getNeighbors(particle, epsilon);
                if (neighborPts.length < minPts) {
                    particle.cluster = -1; // Noise
                } else {
                    expandCluster(particle, neighborPts, clusterIndex, epsilon, minPts);
                    clusterIndex++;
                }
            }

            // Calculate cluster centers
            // for (let i = 0; i < clusterIndex; i++) {
            //     let sumX = 0, sumY = 0, count = 0;
            //     for (let particle of particles) {
            //         if (particle.cluster === i) {
            //             sumX += particle.x;
            //             sumY += particle.y;
            //             count++;
            //         }
            //     }
            //     if (count > 0) {
            //         clusters.push({x: sumX / count, y: sumY / count, index: i});
            //     }
            // }
            
            // Calculate cluster centers and bounding radius
            for (let i = 0; i < clusterIndex; i++) {
                let sumX = 0, sumY = 0, count = 0;
                let maxDist = 0;
                for (let particle of particles) {
                    if (particle.cluster === i) {
                        sumX += particle.x;
                        sumY += particle.y;
                        count++;
                    }
                }
                if (count > 0) {
                    let cx = sumX / count;
                    let cy = sumY / count;
                    for (let particle of particles) {
                        if (particle.cluster === i) {
                            let dx = particle.x - cx;
                            let dy = particle.y - cy;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > maxDist) {
                                maxDist = dist;
                            }
                        }
                    }
                    clusters.push({x: cx, y: cy, index: i, radius: maxDist, size: count});
                }
            }


            // slimes 관리
            if(slimes.length == 0) {
                slimes = clusters.map(cluster => ({
                    id: currentSlimeId++,
                    x: cluster.x,
                    y: cluster.y,
                    index: cluster.index,
                    tick: 0,
                }));
            }
            if(slimes.length < clusters.length) {
                // clusters 순회해서 반경 10 이하인 것들만 slime에 추가
                for(let cluster of clusters) {
                    let isExist = false;
                    for(let slime of slimes) {
                        let dx = cluster.x - slime.x;
                        let dy = cluster.y - slime.y;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        if(dist < 10) {
                            isExist = true;
                            break;
                        }
                    }
                    if(!isExist) {
                        slimes.push({
                            id: currentSlimeId++,
                            x: cluster.x,
                            y: cluster.y,
                            index: cluster.index,
                            tick: 0,
                        });
                    }
                }
            }
            if(slimes.length > clusters.length) {
                // slimes 순회해서 clusters에 없는 것들 제거
                for(let i = slimes.length - 1; i >= 0; i--) {
                    let isExist = false;
                    for(let cluster of clusters) {
                        let dx = cluster.x - slimes[i].x;
                        let dy = cluster.y - slimes[i].y;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        if(dist < 10) {
                            isExist = true;
                            break;
                        }
                    }
                    if(!isExist) {
                        slimes.splice(i, 1);
                    }
                }
            }
            // slimes를 순회해서 가장 가까운 cluster로 slime 정보를 업데이트
            for(let slime of slimes) {
                let minDist = Number.MAX_VALUE;
                let minCluster = null;
                for(let cluster of clusters) {
                    let dx = cluster.x - slime.x;
                    let dy = cluster.y - slime.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    if(dist < minDist) {
                        minDist = dist;
                        minCluster = cluster;
                    }
                }
                slime.x = minCluster.x;
                slime.y = minCluster.y;
                slime.index = minCluster.index;
            }
        }

        function getNeighbors(particle, epsilon) {
            return particles.filter(p => 
                p !== particle && 
                Math.sqrt((p.x - particle.x)**2 + (p.y - particle.y)**2) <= epsilon
            );
        }

        function expandCluster(particle, neighborPts, clusterIndex, epsilon, minPts) {
            particle.cluster = clusterIndex;

            for (let i = 0; i < neighborPts.length; i++) {
                let neighborParticle = neighborPts[i];
                if (neighborParticle.cluster === -1) {
                    neighborParticle.cluster = clusterIndex;
                    let neighborNeighborPts = getNeighbors(neighborParticle, epsilon);
                    if (neighborNeighborPts.length >= minPts) {
                        neighborPts = neighborPts.concat(neighborNeighborPts);
                    }
                }
            }
        }

        function moveCluster(particle, dx, dy) {
            const speed = Math.sqrt(dx*dx + dy*dy);
            const maxSpeed = 5; // Adjust this value to change the threshold for cluster separation
            const moveFactor = Math.max(0, 1 - speed / maxSpeed);

            for (let p of particles) {
                if(p.cluster === -1) continue;
                if (p.cluster === particle.cluster && p !== particle) {
                    p.vx = dx * moveFactor;
                    p.vy = dy * moveFactor;
                }
            }
        }

        function update() {
            time = performance.now() / 1000;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            applyForces();
            dbscan();

            // if (nearestCluster && Math.random() < 0.1) {
            //     const pos = mousePos;
            //     for (let particle of particles) {
            //         if (particle.cluster === nearestCluster.index) {
            //             let dx = pos.x - particle.x;
            //             let dy = pos.y - particle.y;
            //             let dist = Math.sqrt(dx * dx + dy * dy);
            //             let force = 1 / dist * 3;
            //             particle.vx = dx * force;
            //             particle.vy = dy * force;
            //         }
            //     }
            // }

            ctx.font = '25px Days One';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let particle of particles) {
                particle.update();
                particle.draw();
                if(particle.cluster == -1) {
                    ctx.fillStyle = 'white';
                    ctx.fillText('1', particle.x, particle.y);
                }
            }

            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            // Draw cluster indices
            /*
            for (let cluster of clusters) {
                let clusterParticles = particles.filter(p => p.cluster === cluster.index);
                let count = clusterParticles.length;             

                // Draw eyes if there are at least 2 particles in the cluster
                if (count >= 2) {
                    let [x0, y0] = [clusterParticles[0].x, clusterParticles[0].y];
                    let [x1, y1] = [clusterParticles[1].x, clusterParticles[1].y];

                    drawEye4(clusterParticles[0].x, clusterParticles[0].y, clusterParticles[1].x, clusterParticles[1].y, mousePos.x, mousePos.y, cluster.index);
                    drawEye4(clusterParticles[1].x, clusterParticles[1].y, clusterParticles[0].x, clusterParticles[0].y, mousePos.x, mousePos.y, cluster.index);

                    // ctx.fillStyle = 'red';
                    // ctx.fillText(cluster.index, cluster.x, cluster.y);
                    ctx.fillStyle = 'black';

                     // Calculate midpoint
                    let mx = (x0 + x1) / 2;
                    let my = (y0 + y1) / 2;

                    // Calculate the vector (x1 - x0, y1 - y0)
                    let dx = x1 - x0;
                    let dy = y1 - y0;

                    // Calculate orthogonal vector
                    // Use (-dy, dx) or (dy, -dx)
                    let orthoX = dy;
                    let orthoY = -dx;

                    // Determine which direction to move in
                    let o0 = [-dy, dx];
                    let o1 = [dy, -dx];

                    // Normalize the orthogonal vector to 30 units length
                    let length = Math.sqrt(orthoX * orthoX + orthoY * orthoY);
                    let factor = 30 / length;
                    orthoX *= factor;
                    orthoY *= factor;

                    // Calculate new position for fillText
                    let fx = mx + orthoX;
                    let fy = my + orthoY;

                    // Draw text
                    ctx.fillStyle = 'black';
                    ctx.fillText(count, fx, fy);

                    // color change
                    let f = count / 19;
                    let h = f * 0.9;
                    clusterParticles.forEach(p => {
                        let s = p.hsl.s;
                        let l = p.hsl.l;
                        p.to_hsl = { h, s, l };
                    });
                }
            }
            */

            for(let i = 0; i < slimes.length; i++) {
                let slime = slimes[i];
                slime.tick += 1;

                let cluster = clusters[slime.index];
                let clusterParticles = particles.filter(p => p.cluster === cluster.index);
                let count = clusterParticles.length;             

                // Draw eyes if there are at least 2 particles in the cluster
                if (count >= 2) {
                    let [x0, y0] = [clusterParticles[0].x, clusterParticles[0].y];
                    let [x1, y1] = [clusterParticles[1].x, clusterParticles[1].y];

                    if(slime.tick > 60) {
                        drawEye4(clusterParticles[0].x, clusterParticles[0].y, clusterParticles[1].x, clusterParticles[1].y, mouseInfo.x, mouseInfo.y, cluster.index);
                        drawEye4(clusterParticles[1].x, clusterParticles[1].y, clusterParticles[0].x, clusterParticles[0].y, mouseInfo.x, mouseInfo.y, cluster.index);
                    }

                    ctx.fillStyle = 'white';

                     // Calculate midpoint
                    let mx = (x0 + x1) / 2;
                    let my = (y0 + y1) / 2;

                    // Calculate the vector (x1 - x0, y1 - y0)
                    let dx = x1 - x0;
                    let dy = y1 - y0;

                    // Calculate orthogonal vector
                    // Use (-dy, dx) or (dy, -dx)
                    let orthoX = dy;
                    let orthoY = -dx;

                    // Determine which direction to move in
                    let o0 = [-dy, dx];
                    let o1 = [dy, -dx];

                    // Normalize the orthogonal vector to 30 units length
                    let length = Math.sqrt(orthoX * orthoX + orthoY * orthoY);
                    let factor = 30 / length;
                    orthoX *= factor;
                    orthoY *= factor;

                    // Calculate new position for fillText
                    let fx = mx + orthoX;
                    let fy = my + orthoY;

                    // Draw text
                    ctx.fillStyle = 'white';
                    ctx.fillText(count, fx, fy);

                    // color change
                    let f = count / 19;
                    let h = f * 0.9;
                    clusterParticles.forEach(p => {
                        let s = p.hsl.s;
                        let l = p.hsl.l;
                        p.to_hsl = { h, s, l };
                    });
                }

                // ctx.fillStyle = 'red';
                // ctx.fillText(slime.id, slime.x, slime.y);
            }

            // dividers
            let toRemoveDividers = [];
            for(let divider of dividers) {
                if(divider.span > 0) {
                    divider.span -= 1;
                    let f = divider.span / (divider.maxSpan - 1);
                    f = f * f * (3 - 2 * f);
                    for(let particle of divider.members) {
                        let factor = 1;
                        if(clusters[particle.cluster]) {
                            factor = (1 + clusters[particle.cluster].size / (20 - 1)) * 2;
                        }
                        particle.x += divider.vx * 3 * f * factor;
                        particle.y += divider.vy * 3 * f * factor;
                        particle.vx *= 0.5;
                        particle.vy *= 0.5;
                    }
                    if(divider.span === 0) {
                        toRemoveDividers.push(divider);
                    }
                }
            }
            while(toRemoveDividers.length > 0) {
                dividers.splice(dividers.indexOf(toRemoveDividers.shift()), 1);
            }
            
            if(mouseInfo.isDown) {
                // draw mouse trail
                if(mouseInfo.isDividingMode) {
                    ctx.beginPath();
                    //ctx.moveTo(mouseInfo.downX, mouseInfo.downY);
                    for(let i = 0; i < mouseInfo.trail.length; i++) {
                        ctx.lineTo(mouseInfo.trail[i].x, mouseInfo.trail[i].y);
                    }
                    ctx.lineTo(mouseInfo.x, mouseInfo.y);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
                    ctx.lineWidth = 5;
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }
                else if(nearestCluster) {
                    // draw arrow from last two trail points
                    if(mouseInfo.trail.length > 10) {
                        let last = mouseInfo.trail.length - 1;
                        let dx = mouseInfo.trail[last].x - mouseInfo.trail[last - 9].x;
                        let dy = mouseInfo.trail[last].y - mouseInfo.trail[last - 9].y;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        let arrowSize = 10;
                        let arrowAngle = Math.PI / 6;
                        let arrowX = mouseInfo.trail[last].x - dx / dist * arrowSize;
                        let arrowY = mouseInfo.trail[last].y - dy / dist * arrowSize;
                        ctx.beginPath();
                        ctx.moveTo(mouseInfo.trail[last].x, mouseInfo.trail[last].y);
                        ctx.lineTo(arrowX + dy / dist * arrowSize * Math.sin(arrowAngle), arrowY - dx / dist * arrowSize * Math.cos(arrowAngle));
                        ctx.lineTo(arrowX - dy / dist * arrowSize * Math.sin(arrowAngle), arrowY + dx / dist * arrowSize * Math.cos(arrowAngle));
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                        ctx.fill();
                    }
                }
            }

            if(renderGL) {
                renderGL();
            }

            requestAnimationFrame(update);
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function getTouchPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.touches[0].clientX - rect.left,
                y: evt.touches[0].clientY - rect.top
            };
        }

        function onDown(e) {
            const pos = e.touches ? getTouchPos(canvas, e) : getMousePos(canvas, e);
            mouseInfo.x = mouseInfo.downX = pos.x;
            mouseInfo.y = mouseInfo.downY = pos.y;
            if(e.touches) e.preventDefault();
            mouseInfo.offsetX = 0;
            mouseInfo.offsetY = 0;
            mouseInfo.isDown = true;
            mouseInfo.isDividingMode = false;
            mouseInfo.tick = 0;
            mouseInfo.trail = [];

            selectedParticle = null;
            for (let particle of particles) {
                // radius 50px 안에 있는 입자 중 pos와 가장 가까운 입자 선택
                let dx = particle.x - pos.x;
                let dy = particle.y - pos.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 50 && (!selectedParticle || dist < selectedParticle.dist)) {
                    selectedParticle = particle;
                    selectedParticle.dist = dist;
                    mouseInfo.offsetX = pos.x - particle.x;
                    mouseInfo.offsetY = pos.y - particle.y;
                }
            }
            if(!selectedParticle) {
                // nearest cluster
                nearestCluster = null;
                let minDist = Number.MAX_VALUE;
                for (let cluster of clusters) {
                    let dx = cluster.x - pos.x;
                    let dy = cluster.y - pos.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist && dist < 300) {
                        minDist = dist;
                        nearestCluster = cluster;
                    }
                }
                // if (nearestCluster) {
                //     for (let particle of particles) {
                //         if (particle.cluster === nearestCluster.index) {
                //             let dx = pos.x - particle.x;
                //             let dy = pos.y - particle.y;
                //             let dist = Math.sqrt(dx * dx + dy * dy);
                //             let force = 1 / dist;
                //             particle.vx = dx * force;
                //             particle.vy = dy * force;
                //         }
                //     }
                // }
            }
        }

        function onMove(e) {
            const pos = e.touches ? getTouchPos(canvas, e) : getMousePos(canvas, e);
            mouseInfo.x = pos.x;
            mouseInfo.y = pos.y;
            mouseInfo.velocityX = pos.x - mouseInfo.lastX;
            mouseInfo.velocityY = pos.y - mouseInfo.lastY;
            mouseInfo.tick += 1;

            if (selectedParticle) {
                if(e.touches) e.preventDefault();
                
                selectedParticle.x = pos.x - mouseInfo.offsetX;
                selectedParticle.y = pos.y - mouseInfo.offsetY;
                selectedParticle.vx = 0;
                selectedParticle.vy = 0;

                moveCluster(selectedParticle, mouseInfo.velocityX, mouseInfo.velocityY);
            }

            if (nearestCluster) {
                if(mouseInfo.tick === 5) {
                    const dot = (pos.x - nearestCluster.x) * mouseInfo.velocityX + (pos.y - nearestCluster.y) * mouseInfo.velocityY;
                    if(dot < 0) {
                        mouseInfo.isDividingMode = true;
                    }
                }
                if(!mouseInfo.isDividingMode && mouseInfo.tick > 5) {
                    for (let particle of particles) {
                        if (particle.cluster === nearestCluster.index) {
                            let dx = pos.x - particle.x;
                            let dy = pos.y - particle.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            let force = 1 / dist * 3;
                            particle.vx = dx * force;
                            particle.vy = dy * force;
                        }
                    }
                }
            }

            if(mouseInfo.isDown && mouseInfo.isDividingMode) {
                mouseInfo.trail.push({x: pos.x, y: pos.y});
                if(mouseInfo.trail.length > 100) {
                    mouseInfo.trail.shift();
                }
            }

            mouseInfo.lastX = pos.x;
            mouseInfo.lastY = pos.y;
        }

        function onUp() {
            if (selectedParticle) {
                selectedParticle.vx = mouseInfo.velocityX;
                selectedParticle.vy = mouseInfo.velocityY;
            }
            divideSlime();
            selectedParticle = null;
            nearestCluster = null;
            mouseInfo.isDown = false;
            mouseInfo.trail = [];
        }

        function divideSlime0() {
            if(mouseInfo.trail.length > 10) {
                for(let i = 0; i < particles.length; i++) {
                    let particle = particles[i];    
                    for(let j = 0; j < mouseInfo.trail.length; j++) {
                        const dx = particle.x - mouseInfo.trail[j].x;
                        const dy = particle.y - mouseInfo.trail[j].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if(dist < particle.size) {
                            particle.x += dx;
                            particle.y += dy;
                        }
                    }
                }
            }
        }

        function divideSlime() {
            // 모든 cluster를 순회하여 trail을 구성하는 좌표가 cluster의 중심에서 그 cluster의 radius 안에 들어오는 cluster들을 찾는다.
            let targetClusters = [];
            for(let i = 0; i < clusters.length; i++) {
                let cluster = clusters[i];
                for(let j = 0; j < mouseInfo.trail.length; j++) {
                    let dx = cluster.x - mouseInfo.trail[j].x;
                    let dy = cluster.y - mouseInfo.trail[j].y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    if(dist < cluster.radius) {
                        targetClusters.push(cluster.index);
                        break;
                    }
                }
            }

            let processed = false;
            if(mouseInfo.trail.length > 10 && targetClusters.length > 0) {   
                // 모든 입자들을 순회하여 trail을 구성하는 좌표와 모든 거리를 계산해서 리스트를 만들고 가장 짧은 두 점을 찾는다.
                for(let targetCluster of targetClusters) {
                    let ptcls = particles.filter(p => p.cluster === targetCluster);
                    let group0 = {x: 0, y: 0, members: []};
                    let group1 = {x: 0, y: 0, members: []};
                    for(let i = 0; i < ptcls.length; i++) {
                        let particle = ptcls[i];
                        if(targetClusters.includes(particle.cluster)) {
                            let distList = [];
                            for(let j = 0; j < mouseInfo.trail.length; j++) {
                                const dx = particle.x - mouseInfo.trail[j].x;
                                const dy = particle.y - mouseInfo.trail[j].y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                distList.push({i, j, dist});
                            }
                            distList.sort((a, b) => a.dist - b.dist);
                            let p0 = mouseInfo.trail[distList[0].j];
                            let p1 = mouseInfo.trail[distList[1].j];
                            // particle과 p0, p0와 p1을 연결하는 두 벡터를 만들고 두 벡터의 외적을 구해서 particle을 두 그룹으로 나눈다.
                            let v0 = {x: p0.x - particle.x, y: p0.y - particle.y};
                            let v1 = {x: p1.x - p0.x, y: p1.y - p0.y};
                            let cross = v0.x * v1.y - v0.y * v1.x;
                            if(cross > 0) {
                                group0.members.push(particle);
                            }
                            else {
                                group1.members.push(particle);
                            }
                        }
                    }
                    
                    if(group0.members.length > 0 && group1.members.length > 0) {
                        processed = true;
                        // trail의 시작점과 끝점 사이의 벡터를 구해서 이것에 직교하는 두 벡터를 dividing vector로 사용한다. 이때 dividing vector의 방향은 두 그룹의 중점과 cluster의 중점이 만드는 벡터와 내적이 같은 방향으로 한다.
                        let p0 = mouseInfo.trail[0];
                        let p1 = mouseInfo.trail[mouseInfo.trail.length - 1];
                        let v = {x: p1.x - p0.x, y: p1.y - p0.y};
                        let dividingCenter = {x: (p0.x + p1.x) / 2, y: (p0.y + p1.y) / 2};
                        let dividingVector0 = {x: v.y, y: -v.x};
                        let dx = dividingCenter.x - targetCluster.x;
                        let dy = dividingCenter.y - targetCluster.y;
                        let cross = dx * dividingVector0.y - dy * dividingVector0.x;
                        if(cross < 0) {
                            dividingVector0.x = -dividingVector0.x;
                            dividingVector0.y = -dividingVector0.y;
                        }
                        let dividingVector1 = {x: -dividingVector0.x, y: -dividingVector0.y};

                        // normalize dividing vectors
                        let length0 = Math.sqrt(dividingVector0.x * dividingVector0.x + dividingVector0.y * dividingVector0.y);
                        let length1 = Math.sqrt(dividingVector1.x * dividingVector1.x + dividingVector1.y * dividingVector1.y);
                        dividingVector0.x /= length0 + 1e-3;
                        dividingVector0.y /= length0 + 1e-3;
                        dividingVector1.x /= length1 + 1e-3;
                        dividingVector1.y /= length1 + 1e-3;
                        // console.log(dividingCenter, dividingVector0, dividingVector1);
                        // dividing vector0, dividing vector1을 각각의 그룹에 속한 입자들에게 적용한다.
                        // let factor = 100;
                        // for(let i = 0; i < group0.members.length; i++) {
                        //     let particle = group0.members[i];
                        //     particle.x += dividingVector0.x * factor;
                        //     particle.y += dividingVector0.y * factor;
                        // }
                        // for(let i = 0; i < group1.members.length; i++) {
                        //     let particle = group1.members[i];
                        //     particle.x += dividingVector1.x * factor;
                        //     particle.y += dividingVector1.y * factor;
                        // }
                        let span = 30;
                        dividers.push({
                            vx: dividingVector0.x,
                            vy: dividingVector0.y,
                            members: group0.members,
                            span: span,
                            maxSpan: span
                        });
                        dividers.push({
                            vx: dividingVector1.x,
                            vy: dividingVector1.y,
                            members: group1.members,
                            span: span,
                            maxSpan: span
                        });
                    }  
                }
            }

            if(!processed) {
                // 처리가 안된 경우 보험. 클러스터가 애매하게 붙어있을 때도 처리
                if(mouseInfo.trail.length > 10) {
                    if(mouseInfo.trail.length > 10) {
                        for(let i = 0; i < particles.length; i++) {
                            let particle = particles[i];    
                            for(let j = 0; j < mouseInfo.trail.length; j++) {
                                const dx = particle.x - mouseInfo.trail[j].x;
                                const dy = particle.y - mouseInfo.trail[j].y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if(dist < particle.size * 3) {
                                    let force = 1 / (dist + 1e-3);
                                    particle.vx += dx * force;
                                    particle.vy += dy * force;
                                }
                            }
                        }
                    }
                }
            }
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const height = 
            webglCanvas.width = canvas.width;
            webglCanvas.height = canvas.height;
            if(gl && main_program) {
                gl.useProgram(main_program);
                gl.viewport(0, 0, canvas.width, canvas.height);
                const resolutionUniformLocation = gl.getUniformLocation(main_program, "u_resolution");
                gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
            }
            
            // initParticles();
        }

        window.addEventListener('resize', resizeCanvas);

        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onUp);
        canvas.addEventListener('mouseleave', onUp);
        
        canvas.addEventListener('touchstart', onDown);
        canvas.addEventListener('touchmove', onMove);
        canvas.addEventListener('touchend', onUp);

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        resizeCanvas();
        initParticles();
        update();

        particleCountInput.addEventListener('change', initParticles);
        particleSizeInput.addEventListener('change', initParticles);

        function drawEye(x, y, otherX, otherY) {
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();

            const angle = Math.atan2(otherY - y, otherX - x);
            const pupilX = x + Math.cos(angle) * 3;
            const pupilY = y + Math.sin(angle) * 3;
            ctx.fillStyle = "blue";
            ctx.beginPath();
            ctx.arc(pupilX, pupilY, 7, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEye2(x, y, otherX, otherY, targetX, targetY) {
            // 눈 전체 그리기
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();

            // 시선 방향 계산
            const eyeCenterX = (x + otherX) / 2;
            const eyeCenterY = (y + otherY) / 2;
            const angle = Math.atan2(targetY - eyeCenterY, targetX - eyeCenterX);

            // 눈동자 위치 계산
            const maxDistance = 3; // 눈동자가 움직일 수 있는 최대 거리
            const pupilX = x + Math.cos(angle) * maxDistance;
            const pupilY = y + Math.sin(angle) * maxDistance;

            // 눈동자 그리기
            ctx.fillStyle = "blue";
            ctx.beginPath();
            ctx.arc(pupilX, pupilY, 7, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEye3(x, y, targetX, targetY, index) {
            // 눈 전체 그리기
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();

            // 시선 방향 계산
            const angle = Math.atan2(targetY - y, targetX - x);

            // 눈동자 위치 계산
            const maxDistance = 3; // 눈동자가 움직일 수 있는 최대 거리
            let distance = Math.min(maxDistance, Math.hypot(targetX - x, targetY - y) / 10);
            const pupilX = x + Math.cos(angle) * distance;
            const pupilY = y + Math.sin(angle) * distance;

            // 눈동자 그리기
            // ctx.fillStyle = "blue";
            ctx.fillStyle = eye_colors[index];
            ctx.beginPath();
            ctx.arc(pupilX, pupilY, 7, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEye4(x, y, otherX, otherY, targetX, targetY, index) {
            // 시선 방향 계산
            const angle = Math.atan2(targetY - y, targetX - x);
            // 다른 눈과의 각도 계산
            const direction = Math.atan2(otherY - y, otherX - x) + Math.PI/2;

            const isOpened = Math.sin(performance.now()*0.001 + index) > 0;

            ctx.lineWidth = 3; // 선의 두께 설정
            ctx.strokeStyle = "black"; // 선의 색상 설정

            if (isOpened) {
                // 눈 전체 그리기
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();

                // 눈동자 위치 계산
                const maxDistance = 3; // 눈동자가 움직일 수 있는 최대 거리
                let distance = Math.min(maxDistance, Math.hypot(targetX - x, targetY - y) / 10);
                const pupilX = x + Math.cos(angle) * distance;
                const pupilY = y + Math.sin(angle) * distance;

                // 눈동자 그리기
                ctx.fillStyle = eye_colors[index];
                ctx.beginPath();
                ctx.arc(pupilX, pupilY, 7, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.save();
                ctx.translate(x, y);
                // 왼쪽 눈인지 오른쪽 눈인지 판단하여 회전 방향 조정
                if (otherX > x) { // 왼쪽 눈
                    ctx.rotate(direction - Math.PI/2);
                } else { // 오른쪽 눈
                    ctx.rotate(direction + Math.PI/2);
                }
                ctx.strokeStyle = 'white';
                // 눈을 감은 상태 그리기
                ctx.beginPath();
                ctx.moveTo(-10, 0);
                ctx.quadraticCurveTo(0, 5, 10, 0); // 아래 눈꺼풀
                // ctx.moveTo(-10, 0);
                // ctx.quadraticCurveTo(0, -5, 10, 0); // 위 눈꺼풀
                ctx.stroke();
                ctx.restore(); 
            }

            ctx.lineWidth = 1;
        }

        //----

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }

        function initWebGL() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            webglCanvas.width = canvas.width = width;
            webglCanvas.height = canvas.height = height;
            gl.viewport(0, 0, width, height);

            const vertexShaderSource = document.getElementById('vertexShader').text;
            const fragmentShaderSource = document.getElementById('fragmentShader').text;

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            const program = createProgram(gl, vertexShader, fragmentShader);
            main_program = program;
            gl.useProgram(program);

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
            gl.uniform2f(resolutionUniformLocation, width, height);

            const mouseUniformLocation = gl.getUniformLocation(program, "u_mouse");
            const circlesUniformLocation = gl.getUniformLocation(program, "u_circles");
            const colorsUniformLocation = gl.getUniformLocation(program, "u_colors");
            const circleCountUniformLocation = gl.getUniformLocation(program, "u_circleCount");
            const tightnessUniformLocation = gl.getUniformLocation(program, "u_tightness");
            const timeUniformLocation = gl.getUniformLocation(program, "u_time");

            //createCircles(circleCount);

            function render() {
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.uniform1f(timeUniformLocation, time);

                gl.uniform3f(mouseUniformLocation, (2.0 * mouseInfo.x - canvas.width) / canvas.height, (2.0 * (canvas.height - mouseInfo.y) - canvas.height) / canvas.height, mouseInfo.isDown ? 1 : 0);

                const circlePositions = new Float32Array(particles.flatMap(c => [
                    (2.0 * c.x - canvas.width) / canvas.height,
                    (2.0 * (canvas.height - c.y) - canvas.height) / canvas.height
                ]));
                gl.uniform2fv(circlesUniformLocation, circlePositions);

                const circleColors = new Float32Array(particles.flatMap(c => [
                    c.color.r,
                    c.color.g,
                    c.color.b
                ]));
                gl.uniform3fv(colorsUniformLocation, circleColors);

                gl.uniform1i(circleCountUniformLocation, particles.length);
                gl.uniform1f(tightnessUniformLocation, tightness);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            renderGL = render;
        }


        function generateBrightGreenColor(f) {
            // //const h = 80 + Math.random() * 60; // Hue range from 80 to 140 (yellow-green to green-cyan)
            // const h = 0 + Math.random() * 360; // Hue range from 80 to 140 (yellow-green to green-cyan)
            // const s = 70 + Math.random() * 30; // Saturation range from 70% to 100%
            // const l = 40 + Math.random() * 30; // Lightness range from 40% to 70%
            // return hslToRgb(h, s, l);

            return {
                h: f * 0.9,
                s: 0.3 + f * 0.7,
                l: 0.2 + f * 0.3
            };
        }

        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        function hslToNormalizedRgb(h, s, l) {
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return {
                r: r,
                g: g,
                b: b
            };
        }

        function hslToRgb(h, s, l) {
            const rgb = hslToNormalizedRgb(h, s, l);
            return {
                r: Math.round(rgb.r * 255),
                g: Math.round(rgb.g * 255),
                b: Math.round(rgb.b * 255)
            };
        }
    </script>
</body>
</html>