<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
    <title>Clustered Slime with Eyes</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        canvas {
            width: 100vw;
            height: 100vh;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            width: 100%;
            position: fixed;
            bottom: 0;
            z-index: 10;
        }
        .control {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        label {
            margin-bottom: 5px;
        }
        input[type="range"], input[type="number"] {
            width: 100px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #container { position: relative; }
        canvas { position: absolute; top: 0; left: 0; }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="webglCanvas"></canvas>
        <canvas id="canvas"></canvas>
    </div>
    <div class="controls" style="display: none;">
        <div class="control">
            <label for="particleCount">Particle Count:</label>
            <input type="number" id="particleCount" min="10" max="1000" value="20">
        </div>
        <div class="control">
            <label for="particleSize">Particle Size:</label>
            <input type="range" id="particleSize" min="2" max="20" value="20">
        </div>
        <div class="control">
            <label for="repulsionFactor">Repulsion Factor:</label>
            <input type="range" id="repulsionFactor" min="0" max="100" value="79">
        </div>
        <div class="control">
            <label for="attractionDistance">Attraction Distance:</label>
            <input type="range" id="attractionDistance" min="0" max="200" value="73">
        </div>
        <div class="control">
            <label for="attractionFactor">Attraction Factor:</label>
            <input type="range" id="attractionFactor" min="0" max="100" value="76">
        </div>
        <div class="control">
            <label for="clusterEpsilon">Cluster Epsilon:</label>
            <input type="range" id="clusterEpsilon" min="10" max="100" value="50">
        </div>
        <div class="control">
            <label for="clusterMinPts">Cluster Min Points:</label>
            <input type="number" id="clusterMinPts" min="1" max="10" value="1">
        </div>
    </div>
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec2 u_resolution;
        uniform vec2 u_circles[20];
        uniform vec3 u_colors[20];
        uniform int u_circleCount;
        uniform float u_tightness;

        float metaball(vec2 p, vec2 center, float radius) {
            return radius * radius / dot(p - center, p - center);
        }

        vec3 backgroundGradient(vec2 uv) {
            float t = uv.y;
            return mix(vec3(0.1, 0.2, 0.3), vec3(0.5, 0.7, 0.9), t);
        }

        void main() {
            vec2 uv = (2.0 * gl_FragCoord.xy - u_resolution) / u_resolution.y;
            float sum = 0.0;
            vec3 mixedColor = vec3(0.0);
            float totalWeight = 0.0;

            for (int i = 0; i < 20; i++) {
                if (i >= u_circleCount) break;
                float influence = metaball(uv, u_circles[i], 0.05);
                sum += influence;
                mixedColor += influence * u_colors[i];
                totalWeight += influence;
            }

            float threshold = u_tightness;
            float value = smoothstep(threshold - 0.05, threshold, sum);

            vec3 backgroundColor = backgroundGradient(uv * 0.5 + 0.5);
            if (totalWeight > 0.0) {
                mixedColor /= totalWeight; // Normalize the mixed color by the total influence
            }

            mixedColor = mix(mixedColor, vec3(1.0), value * 0.5); // Lighten the mixed color

            gl_FragColor = vec4(mix(backgroundColor, mixedColor, value), 1.0);
        }
    </script>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        let selectedParticle = null;
        let clusters = [];
        let lastMousePos = { x: 0, y: 0 };
        let mouseVelocity = { x: 0, y: 0 };
        let paused = false;
        const particleCountInput = document.getElementById('particleCount');
        const particleSizeInput = document.getElementById('particleSize');
        const repulsionFactorInput = document.getElementById('repulsionFactor');
        const attractionDistanceInput = document.getElementById('attractionDistance');
        const attractionFactorInput = document.getElementById('attractionFactor');
        const clusterEpsilonInput = document.getElementById('clusterEpsilon');
        const clusterMinPtsInput = document.getElementById('clusterMinPts');

        const webglCanvas = document.getElementById('webglCanvas');
        const gl = webglCanvas.getContext('webgl');
        let tightness = 1;
        let randerGL = null;

        class Particle {
            constructor(x, y, size, color) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.vx = 0;
                this.vy = 0;
                this.cluster = -1; // -1 means no cluster
            }

            update() {
                if (this !== selectedParticle && !paused) {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < this.size*2 || this.x > canvas.width - this.size*2) this.vx *= -0.5;
                    if (this.y < this.size*2 || this.y > canvas.height - this.size*2) this.vy *= -0.5;

                    this.x = Math.max(this.size*2, Math.min(canvas.width - this.size*2, this.x));
                    this.y = Math.max(this.size*2, Math.min(canvas.height - this.size*2, this.y));

                    this.vx *= 0.99;
                    this.vy *= 0.99;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size *0.5, 0, Math.PI * 2);
                ctx.fillStyle = this === selectedParticle ? 'rgba(255, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.0)';
                ctx.fill();
                ctx.strokeStyle = this === selectedParticle ? 'red' : 'rgba(0, 0, 255, 1)';
                ctx.closePath();
                //ctx.stroke();
            }

            isPointInside(x, y) {
                const dx = this.x - x;
                const dy = this.y - y;
                return dx * dx + dy * dy <= this.size * this.size;
            }
        }

        function initParticles() {
            particles = [];
            const count = parseInt(particleCountInput.value);
            const size = parseInt(particleSizeInput.value);
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(
                    Math.random() * (canvas.width - 2 * size) + size,
                    Math.random() * (canvas.height - 2 * size) + size,
                    size,
                    generateBrightGreenColor()
                ));
            }

            initWebGL();
        }

        function applyForces() {
            const repulsionFactor = parseFloat(repulsionFactorInput.value) / 1000;
            const attractionDist = parseFloat(attractionDistanceInput.value);
            const attractionFactor = parseFloat(attractionFactorInput.value) / 10000;

            for (let i = 0; i < particles.length - 1; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    if (particles[i] === selectedParticle || particles[j] === selectedParticle) continue;

                    const dx = particles[j].x - particles[i].x;
                    const dy = particles[j].y - particles[i].y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);
                    const minDist = particles[i].size + particles[j].size;

                    if (dist < minDist) {
                        // Strong repulsion to prevent overlap
                        const force = repulsionFactor * (minDist - dist) / dist;
                        const fx = dx * force;
                        const fy = dy * force;
                        particles[i].vx -= fx;
                        particles[i].vy -= fy;
                        particles[j].vx += fx;
                        particles[j].vy += fy;
                    } else if (dist < attractionDist) {
                        // Weak attraction
                        const force = attractionFactor * (dist - minDist) / dist;
                        const fx = dx * force;
                        const fy = dy * force;
                        particles[i].vx += fx;
                        particles[i].vy += fy;
                        particles[j].vx -= fx;
                        particles[j].vy -= fy;
                    }
                }
            }
        }

        function dbscan() {
            const epsilon = parseFloat(clusterEpsilonInput.value);
            const minPts = parseInt(clusterMinPtsInput.value);
            let clusterIndex = 0;
            clusters = [];

            // Reset all clusters
            for (let particle of particles) {
                particle.cluster = -1;
            }

            for (let particle of particles) {
                if (particle.cluster !== -1) continue;

                const neighborPts = getNeighbors(particle, epsilon);
                if (neighborPts.length < minPts) {
                    particle.cluster = -1; // Noise
                } else {
                    expandCluster(particle, neighborPts, clusterIndex, epsilon, minPts);
                    clusterIndex++;
                }
            }

            // Calculate cluster centers
            for (let i = 0; i < clusterIndex; i++) {
                let sumX = 0, sumY = 0, count = 0;
                for (let particle of particles) {
                    if (particle.cluster === i) {
                        sumX += particle.x;
                        sumY += particle.y;
                        count++;
                    }
                }
                if (count > 0) {
                    clusters.push({x: sumX / count, y: sumY / count, index: i});
                }
            }
        }

        function getNeighbors(particle, epsilon) {
            return particles.filter(p => 
                p !== particle && 
                Math.sqrt((p.x - particle.x)**2 + (p.y - particle.y)**2) <= epsilon
            );
        }

        function expandCluster(particle, neighborPts, clusterIndex, epsilon, minPts) {
            particle.cluster = clusterIndex;

            for (let i = 0; i < neighborPts.length; i++) {
                let neighborParticle = neighborPts[i];
                if (neighborParticle.cluster === -1) {
                    neighborParticle.cluster = clusterIndex;
                    let neighborNeighborPts = getNeighbors(neighborParticle, epsilon);
                    if (neighborNeighborPts.length >= minPts) {
                        neighborPts = neighborPts.concat(neighborNeighborPts);
                    }
                }
            }
        }

        function moveCluster(particle, dx, dy) {
            const speed = Math.sqrt(dx*dx + dy*dy);
            const maxSpeed = 5; // Adjust this value to change the threshold for cluster separation
            const moveFactor = Math.max(0, 1 - speed / maxSpeed);

            for (let p of particles) {
                if (p.cluster === particle.cluster && p !== particle) {
                    p.x += dx * moveFactor;
                    p.y += dy * moveFactor;
                }
            }
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            applyForces();
            dbscan();

            for (let particle of particles) {
                particle.update();
                particle.draw();
            }

            // Draw cluster indices
            ctx.font = '12px Arial';
            ctx.fillStyle = 'black';
            for (let cluster of clusters) {
                // count particles in this cluster using .filter
                let count = particles.filter(p => p.cluster === cluster.index).length;
                //ctx.fillText(cluster.index, cluster.x, cluster.y);
                ctx.fillText(count, cluster.x, cluster.y);

                // Draw eyes if there are at least 2 particles in the cluster
                if (count >= 2) {
                    let clusterParticles = particles.filter(p => p.cluster === cluster.index);
                    drawEye(clusterParticles[0].x, clusterParticles[0].y, clusterParticles[1].x, clusterParticles[1].y);
                    drawEye(clusterParticles[1].x, clusterParticles[1].y, clusterParticles[0].x, clusterParticles[0].y);
                }
            }

            if(renderGL) {
                renderGL();
            }

            requestAnimationFrame(update);
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function getTouchPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.touches[0].clientX - rect.left,
                y: evt.touches[0].clientY - rect.top
            };
        }

        function onDown(e) {
            const pos = e.touches ? getTouchPos(canvas, e) : getMousePos(canvas, e);
            if(e.touches) e.preventDefault();
            for (let particle of particles) {
                if (particle.isPointInside(pos.x, pos.y)) {
                    selectedParticle = particle;
                    lastMousePos = pos;
                    break;
                }
            }
        }

        function onMove(e) {
            if (selectedParticle) {
                const pos = e.touches ? getTouchPos(canvas, e) : getMousePos(canvas, e);
                if(e.touches) e.preventDefault();
                const dx = pos.x - lastMousePos.x;
                const dy = pos.y - lastMousePos.y;

                selectedParticle.x = pos.x;
                selectedParticle.y = pos.y;
                selectedParticle.vx = 0;
                selectedParticle.vy = 0;

                moveCluster(selectedParticle, dx, dy);

                mouseVelocity = {
                    x: dx,
                    y: dy
                };

                lastMousePos = pos;
            }
        }

        function onUp() {
            if (selectedParticle) {
                selectedParticle.vx = mouseVelocity.x;
                selectedParticle.vy = mouseVelocity.y;
            }
            selectedParticle = null;
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initParticles();
        }

        window.addEventListener('resize', resizeCanvas);

        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onUp);
        canvas.addEventListener('mouseleave', onUp);
        
        canvas.addEventListener('touchstart', onDown);
        canvas.addEventListener('touchmove', onMove);
        canvas.addEventListener('touchend', onUp);

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });

        resizeCanvas();
        initParticles();
        update();

        particleCountInput.addEventListener('change', initParticles);
        particleSizeInput.addEventListener('change', initParticles);

        function drawEye(x, y, otherX, otherY) {
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();

            const angle = Math.atan2(otherY - y, otherX - x);
            const pupilX = x + Math.cos(angle) * 3;
            const pupilY = y + Math.sin(angle) * 3;
            ctx.fillStyle = "blue";
            ctx.beginPath();
            ctx.arc(pupilX, pupilY, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        //----

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }

        function initWebGL() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            webglCanvas.width = canvas.width = width;
            webglCanvas.height = canvas.height = height;
            gl.viewport(0, 0, width, height);

            const vertexShaderSource = document.getElementById('vertexShader').text;
            const fragmentShaderSource = document.getElementById('fragmentShader').text;

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            const program = createProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(program);

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
            gl.uniform2f(resolutionUniformLocation, width, height);

            const circlesUniformLocation = gl.getUniformLocation(program, "u_circles");
            const colorsUniformLocation = gl.getUniformLocation(program, "u_colors");
            const circleCountUniformLocation = gl.getUniformLocation(program, "u_circleCount");
            const tightnessUniformLocation = gl.getUniformLocation(program, "u_tightness");

            //createCircles(circleCount);

            function render() {
                gl.clear(gl.COLOR_BUFFER_BIT);

                const circlePositions = new Float32Array(particles.flatMap(c => [
                    (2.0 * c.x - width) / height,
                    (2.0 * (height - c.y) - height) / height
                ]));
                gl.uniform2fv(circlesUniformLocation, circlePositions);

                const circleColors = new Float32Array(particles.flatMap(c => [
                    c.color.r / 255,
                    c.color.g / 255,
                    c.color.b / 255
                ]));
                gl.uniform3fv(colorsUniformLocation, circleColors);

                gl.uniform1i(circleCountUniformLocation, particles.length);
                gl.uniform1f(tightnessUniformLocation, tightness);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            renderGL = render;

            //render();
        }

        // function createCircles(count) {
        //     circles = [];
        //     for (let i = 0; i < count; i++) {
        //         circles.push({
        //             x: Math.random() * webglCanvas.width,
        //             y: Math.random() * webglCanvas.height,
        //             radius: 20,
        //             color: generateBrightGreenColor()
        //         });
        //     }
        // }

        function generateBrightGreenColor() {
            const h = 80 + Math.random() * 60; // Hue range from 80 to 140 (yellow-green to green-cyan)
            const s = 70 + Math.random() * 30; // Saturation range from 70% to 100%
            const l = 40 + Math.random() * 30; // Lightness range from 40% to 70%
            return hslToRgb(h, s, l);
        }

        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }
    </script>
</body>
</html>