<!doctype html>
<meta charset="utf-8">
<style>
  body {
    margin: 0;
    display: flex;
    justify-content: center;
  }
  
  #container {
    margin-top: 50px;
    display: flex;  
  }
  
  #video-canvas {
    order: 1;
  }
  
  #captured {
    order: 2;
    margin-left: 20px;
  }
  
  #ui {
    display: flex;
    justify-content: center;
    margin-top: 20px;
    margin-bottom: 20px;
  }
  
  #ui button {
    margin-right: 10px;
  }
  
  #fps {
    font-family: monospace;
    opacity: 0.5;
  }
  
  #message {
    text-align: center;
    opacity: 0.5;
    font-size: 20px;
    transition: 0.5s opacity;
  }
  
  #text-for-copy {
    opacity: 0;
  }
</style>
<body>
  <div id="container">
    <div id="video-canvas">
      <div>초록색 사각형에 그림의 외각 사각형을 맞춰주세요. (모서리의 붉은 점이 8개가 되도록)</div>
      <div id="fps"></div>
    </div>
    <div id="captured">
      <div id="message">그림을 기다리는 중...</div>
      <div id="ui">
        <button id="copy">가져가기</button>
        <button id="download">다운로드</button>
      </div>
    </div>
  </div>
  <input id="text-for-copy">
</body>
<script src="./potrace.js"></script>
<script>
  let el_fps = document.querySelector('#fps');
  let video = document.createElement('video');
  let ctx = document.createElement('canvas').getContext('2d');
  document.querySelector('#video-canvas').appendChild(ctx.canvas);
  
  let el_message = document.querySelector('#message');
  let el_text_for_copy = document.querySelector('#text-for-copy');
  let el_copy = document.querySelector('#copy');
  let el_download = document.querySelector('#download');
  
  const times = [];
  
  let is_video_ready = false;
  let bm;
  let pathlist = [];
  let info = {
    isReady: false,
    turnpolicy: 'minority', 
    turdsize: 2,
    optcurve: true,
    alphamax: 1,
    opttolerance: 0.2,
  };

  navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(function(stream) {
    video.srcObject = stream;
    video.setAttribute("playsinline", true); // required to tell iOS safari we don't want fullscreen
    video.play();
    requestAnimationFrame(loop);
  });
  
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }
  
  Point.prototype.copy = function(){
    return new Point(this.x, this.y);
  };
  
  function Bitmap(w, h) {
    this.w = w;
    this.h = h;
    this.size = w * h;
    this.data = new Uint8Array(this.size);
  }

  Bitmap.prototype.at = function (x, y) {
    return (x >= 0 && x < this.w && y >=0 && y < this.h) && 
        this.data[this.w * y + x] === 1;
  };

  Bitmap.prototype.index = function(i) {
    let point = new Point();
    point.y = Math.floor(i / this.w);
    point.x = i - point.y * this.w;
    return point;
  };

  Bitmap.prototype.flip = function(x, y) {
    if (this.at(x, y)) {
      this.data[this.w * y + x] = 0;
    } else {
      this.data[this.w * y + x] = 1;
    }
  };
    
  Bitmap.prototype.copy = function() {
    let bm = new Bitmap(this.w, this.h), i;
    for (i = 0; i < this.size; i++) {
      bm.data[i] = this.data[i];
    }
    return bm;
  };

  function Path() {
    this.area = 0;
    this.len = 0;
    this.curve = {};
    this.pt = [];
    this.minX = 100000;
    this.minY = 100000;
    this.maxX = -1;
    this.maxY = -1;
  }
  
  function bmToPathlist() {
    pathlist = [];
    let bm1 = bm,
      currentPoint = new Point(0, 0),
      path;
    
    function findNext(point) {
      let i = bm1.w * point.y + point.x;
      while (i < bm1.size && bm1.data[i] !== 1) {
        i++;
      }
      return i < bm1.size && bm1.index(i);
    }
    
    function majority(x, y) {
      let i, a, ct;
      for (i = 2; i < 5; i++) {
        ct = 0;
        for (a = -i + 1; a <= i - 1; a++) {
          ct += bm1.at(x + a, y + i - 1) ? 1 : -1;
          ct += bm1.at(x + i - 1, y + a - 1) ? 1 : -1;
          ct += bm1.at(x + a - 1, y - i) ? 1 : -1;
          ct += bm1.at(x - i, y + a) ? 1 : -1;
        }
        if (ct > 0) {
          return 1;
        } else if (ct < 0) {
          return 0;
        }
      }
      return 0;
    }
    
    function findPath(point) {
      let path = new Path(),
        x = point.x, y = point.y,
        dirx = 0, diry = 1, tmp;
      
      path.sign = bm.at(point.x, point.y) ? "+" : "-";
      
      while (1) {
        path.pt.push(new Point(x, y));
        if (x > path.maxX)
          path.maxX = x;
        if (x < path.minX)
          path.minX = x;
        if (y > path.maxY)
          path.maxY = y;
        if (y < path.minY)
          path.minY = y;
        path.len++;
        
        x += dirx;
        y += diry;
        path.area -= x * diry;
        
        if (x === point.x && y === point.y)
          break;
        
        let l = bm1.at(x + (dirx + diry - 1 ) / 2, y + (diry - dirx - 1) / 2);
        let r = bm1.at(x + (dirx - diry - 1) / 2, y + (diry + dirx - 1) / 2);
        
        if (r && !l) {
          if (info.turnpolicy === 'right' ||
          (info.turnpolicy === 'black' && path.sign === '+') ||
          (info.turnpolicy === 'white' && path.sign === '-') ||
          (info.turnpolicy === 'majority' && majority(x, y)) ||
          (info.turnpolicy === 'minority' && !majority(x, y))) {
            tmp = dirx;
            dirx = -diry;
            diry = tmp;
          } else {
            tmp = dirx;
            dirx = diry;
            diry = -tmp;
          }
        } else if (r) {
          tmp = dirx;
          dirx = -diry;
          diry = tmp;
        } else if (!l) {
          tmp = dirx;
          dirx = diry;
          diry = -tmp;
        }
      }
      return path;
    }
    
    function xorPath(path){
      let y1 = path.pt[0].y,
        len = path.len,
        x, y, maxX, minY, i, j;
      for (i = 1; i < len; i++) {
        x = path.pt[i].x;
        y = path.pt[i].y;
        
        if (y !== y1) {
          minY = y1 < y ? y1 : y;
          maxX = path.maxX;
          for (j = x; j < maxX; j++) {
            bm1.flip(j, minY);
          }
          y1 = y;
        }
      }
      
    }
    
    while (currentPoint = findNext(currentPoint)) {

      path = findPath(currentPoint);
      
      xorPath(path);
      
      if (path.area > info.turdsize) {
        pathlist.push(path);
      }
    }
    
  }
  
  function check_fps() {
    const now = performance.now();
    while (times.length > 0 && times[0] <= now - 1000) {
      times.shift();
    }
    times.push(now);
    return times.length;
  }
  
  function check_corner(path) {
    let step = 20;
    let candis = [];
    let corners = [];
    ctx.fillStyle = 'red';
    for(let i = 0; i < path.pt.length; i++) {
      let next_i = (i + step) % path.pt.length;
      let prev_i = i - step;
      if(prev_i < 0) prev_i = prev_i + path.pt.length;
      let pt = path.pt[i];
      let pt_next = path.pt[next_i];
      let pt_prev = path.pt[prev_i];
      let va = { x: pt_next.x - pt.x, y: pt_next.y - pt.y };
      let len_va = Math.sqrt(va.x*va.x+va.y*va.y);
      va.x /= len_va + 1e-9;
      va.y /= len_va + 1e-9;
      let vb = { x: pt_prev.x - pt.x, y: pt_prev.y - pt.y };
      let len_vb = Math.sqrt(vb.x*vb.x+vb.y*vb.y);
      vb.x /= len_va + 1e-9;
      vb.y /= len_va + 1e-9;
      let dot = va.x*vb.x + va.y*vb.y;
      pt.adot = Math.abs(dot);
      if(Math.abs(dot) < 0.3) {
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 1, 0, Math.PI * 2);
        let hue = (i / (path.pt.length - 1)) * 270;
        //ctx.fillStyle = `hsl(${hue},100%,50%)`;
        //ctx.fill();
        candis.push(i);
      }
    }
    
    for(let i = 0; i < candis.length; i++) {
      let ci = candis[i];
      let min_adot = Number.MAX_VALUE;
      let pt = null;
      for(let j = -20; j <= 20; j++) {
        let cij = ci + j;
        if(cij < 0) cij = cij + path.pt.length;
        if(cij > path.pt.length - 1) cij = cij % path.pt.length;
        if(path.pt[cij].adot < min_adot) {
          min_adot = path.pt[cij].adot;
          pt = path.pt[cij];
        }
      }
      if(pt) {
        if(corners.indexOf(pt) == -1) {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 5, 0, Math.PI * 2);
          let hue = (i / (path.pt.length - 1)) * 270;
          ctx.fill();
          corners.push(pt);
        }
      }
    }
    
    return corners.length;
  }
  
  let score = 0;
  function loop() {
    if(!is_video_ready) {
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        ctx.canvas.width = video.videoWidth;
        ctx.canvas.height = video.videoHeight;
        ctx.canvas.style.transform = 'scale(-1, 1)';
        bm = new Bitmap(video.videoWidth, video.videoHeight);
        is_video_ready = true;
      }
    }
    else {
      ctx.drawImage(video, 0, 0);
      
      let im = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
      let l = im.data.length, i, j, gray, bin;
      for (i = 0, j = 0; i < l; i += 4, j++) {
        gray = 0.2126 * im.data[i] + 0.7153 * im.data[i + 1] + 0.0721 * im.data[i + 2];
        bin = (gray < 100 ? 1 : 0);
        im.data[i + 0] = (1-bin) * 255;
        im.data[i + 1] = (1-bin) * 255;
        im.data[i + 2] = (1-bin) * 255;
        bm.data[j] = bin;
      }
      //ctx.putImageData(im, 0, 0);
      ctx.strokeStyle = 'cyan';
      ctx.fillStyle = 'magenta';
      bmToPathlist();
      
      let cx = ctx.canvas.width / 2;
      let cy = ctx.canvas.height / 2;
      let p_count = 0;
      let squares = [];
      for(let i = 0; i < pathlist.length; i++) {
        let path = pathlist[i];
        if(path.area > 150 * 150 && path.area < 300 * 300) {
          let center_x = (path.minX + path.maxX) / 2;
          let center_y = (path.minY + path.maxY) / 2;
          let dx = cx - center_x;
          let dy = cy - center_y;
          let d = Math.sqrt(dx*dx + dy*dy);
          if(d < 50) {
            p_count++;
            squares.push(path);
            let corner_count = check_corner(path);
            if(corner_count === 4) {
              ctx.beginPath();
              for(let j = 0; j < path.pt.length; j++) {
                let pt = path.pt[j];
                if(j == 0) {
                  ctx.moveTo(pt.x, pt.y);
                }
                else {
                  ctx.lineTo(pt.x, pt.y);
                }
              }
              ctx.stroke();
            }
            ctx.fillText(corner_count, path.pt[0].x, path.pt[0].j);  
          }
        }
      }
      
      if(p_count === 2) {
        score += 1; 
      }
      else {
        score -= 5;
      }
      
      score = Math.max(Math.min(score, 60), 0);
      
      if(score === 60 && p_count === 2) {
        let square = squares[0].area > squares[1].area ? squares[1] : squares[0];
        prepare(video, square);
        score = 0;
      }
      
      let w0 = 256;
      let r = 30;
      let w1 = w0 + r;
      ctx.strokeStyle = 'green';
      ctx.strokeRect(cx - w0/2, cy - w0/2, w0, w0);
      ctx.strokeRect(cx - w1/2, cy - w1/2, w1, w1);
      
      el_fps.textContent = `fps: ${check_fps()} path_count: ${p_count}, : score: ${score}`;
    }
    requestAnimationFrame(loop);
  }
  
  let g = document.createElement('canvas').getContext('2d');
  let c = document.createElement('canvas').getContext('2d');
  c.canvas.width = 256;
  c.canvas.height = 256;
  
  let captured_ctx = document.createElement('canvas').getContext('2d');
  document.querySelector('#captured').appendChild(captured_ctx.canvas);
  captured_ctx.canvas.width = 480;
  captured_ctx.canvas.height = 480;
  
  function isInsideBound(bound, path) {
    let result = false;
    if((path.minX > bound.minX && path.maxX < bound.maxX) &&
       (path.minY > bound.minY && path.maxY < bound.maxY)) {
      result = true;
    }
    return result;
  }
  
  function prepare(video, square) {
    g.canvas.width = ctx.canvas.width;
    g.canvas.height = ctx.canvas.height;
    g.fillStyle = 'white';
    g.fillRect(0, 0, g.canvas.width, g.canvas.height);

    let clipPath = new Path2D();
    g.beginPath();
    for(let j = 0; j < square.pt.length; j++) {
      let pt = square.pt[j];
      if(j == 0) {
        clipPath.moveTo(pt.x, pt.y);
        g.moveTo(pt.x, pt.y);
      }
      else {
        clipPath.lineTo(pt.x, pt.y);
        g.lineTo(pt.x, pt.y);
      }
    }
    clipPath.closePath();

    g.save();
    g.clip(clipPath);
    g.drawImage(video, 0, 0);
    g.restore();

    g.closePath();
    g.lineWidth = 10;
    g.strokeStyle = 'white';
    g.stroke();
    
    // ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    c.drawImage(g.canvas, g.canvas.width/2 - 128, g.canvas.height/2 - 128, 256, 256, 0, 0, c.canvas.width, c.canvas.height);
    
    Potrace.loadImageFromUrl(c.canvas.toDataURL('image/jpeg', 1.0));
    Potrace.process(function(){
      displaySVG(1);
    });
  }
  
  let d_str = '';
  function displaySVG(size, type){
    let path_str = Potrace.getSVG(size, type).trim();
    d_str = path_str;
    let p = new Path2D(path_str);
    let g = captured_ctx;
    g.clearRect(0, 0, g.canvas.width, g.canvas.height);
    //let hue = Math.random() * 360 | 0;
    //captured_ctx.fillStyle = `hsl(${hue}deg, 100%, 50%)`;
    let ratio = captured_ctx.canvas.width / c.canvas.width;
    g.fillStyle = 'black';
    g.save();
    g.scale(ratio, ratio);
    g.fill(p);
    g.restore();
    
    el_message.innerHTML = '잡았다!';
    el_text_for_copy.value = d_str;
    el_message.style.opacity = 1;
    setTimeout(() => {
      el_message.style.opacity = 0;
    }, 3000);
  }
  
  el_copy.addEventListener('click', (e) => {
    el_text_for_copy.select();
    document.execCommand("copy");
    
    localStorage['critter-path'] = d_str;
  });
  
  el_download.addEventListener('click', (e) => {
    let el = document.createElement('a');
    
    let w = c.canvas.width;
    let h = c.canvas.height;
    
    let svg_str = `<svg id="svg" version="1.1" width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg"><path d="${d_str}" stroke="none" fill="black" fill-rule="evenodd"/></svg>`;
    
    el.href = 'data:image/svg+xml,' + svg_str;
    el.download = `그림_${(new Date()).getTime()}.svg`;
    el.click();
  });
</script>